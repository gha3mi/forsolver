var tipuesearch = {"pages":[{"title":" forsolver ","text":"forsolver ForSolver : A Fortran library of linear and nonlinear solvers. Usage Linear system solver use forsolver , only : solve x = solve ( A , b , method ) available methods (optional): gesv gels Nonlinear system solver use forsolver , only : nlsolver call nls % set_options (& lin_method ,& nl_method ,& fdm_method ,& fdm_tol ,& cs_tol ,& TolFun ,& maxit ,& nmp ,& verbosity ) call nls % solve ( F , dFdx , x0 , x_sol ) available nl_methods: newton newton-modified newton-quasi-fd newton-quasi-fd-modified newton-quasi-cs newton-quasi-cs-modified fd: finite difference method cs: complex step method Requirements A Fortran Compiler BLAS Library Fortran Package Manager (fpm) fpm Dependency If you want to use ForSolver as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forsolver = { git = \"https://github.com/gha3mi/forsolver.git\" } Runing Tests Execute the following commands to run tests with specific compilers: fpm @<compiler>-test compiler: ifx, ifort, gfortran, nvfortran Examples Example 1: Linear System Solver program example1 use kinds use forsolver implicit none real ( rk ), dimension (:,:), allocatable :: A real ( rk ), dimension (:) , allocatable :: x , b integer :: m , n , i , j m = 3 n = 2 allocate ( A ( m , n ), b ( m ), x ( n )) A ( 1 ,:) = [ 1.0_rk , 5.0_rk ] A ( 2 ,:) = [ 3.0_rk , 1.0_rk ] A ( 3 ,:) = [ - 2.0_rk , 4.0_rk ] b = [ 4.0_rk , - 2.0_rk , 3.0_rk ] x = solve ( A , b ) end program example1 Example 2: Newton's Method for Root Finding module my_function3 use kinds implicit none contains function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1 function dF1dx ( x ) result ( dFdx_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: dFdx_val dFdx_val = 1 5.0_rk * x ** 2 + 8.0_rk end function dF1dx end module my_function3 program example2 use forsolver use my_function3 implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x call nls % set_options (& nl_method = 'newton' ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 1 ) call nls % solve ( F = F1 , dFdx = dF1dx , x0 = 1 0.0_rk , x_sol = x ) end program example2 API Documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForSolver using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForSolver are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"nlsolver – forsolver ","text":"type, public :: nlsolver Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: lin_method character(len=:), public, allocatable :: nl_method character(len=:), public, allocatable :: fdm_method real(kind=rk), public :: TolFun real(kind=rk), public :: fdm_tol real(kind=rk), public :: cs_tol integer, public :: maxit integer, public :: nmp integer, public :: verbosity Finalization Procedures final :: deallocate_solver private pure elemental subroutine deallocate_solver (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name type( nlsolver ), intent(inout) :: this Type-Bound Procedures procedure, public :: set_options private impure subroutine set_options (this, nl_method, lin_method, maxit, TolFun, alpha0, c1, c2, nmp, fdm_method, fdm_tol, cs_tol, stepsize, verbosity) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this character(len=*), intent(in), optional :: nl_method character(len=*), intent(in), optional :: lin_method integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: TolFun real(kind=rk), intent(in), optional :: alpha0 real(kind=rk), intent(in), optional :: c1 real(kind=rk), intent(in), optional :: c2 integer, intent(in), optional :: nmp character(len=*), intent(in), optional :: fdm_method real(kind=rk), intent(in), optional :: fdm_tol real(kind=rk), intent(in), optional :: cs_tol character(len=*), intent(in), optional :: stepsize integer, intent(in), optional :: verbosity procedure, public :: newton_rel_T0 private impure subroutine newton_rel_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol procedure, public :: newton_rel_T1 private impure subroutine newton_rel_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol procedure, public :: newton_complex_step_rel_T0 private impure subroutine newton_complex_step_rel_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol procedure, public :: newton_complex_step_rel_T1 private impure subroutine newton_complex_step_rel_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol generic, public :: solve => newton_rel_T0 , newton_rel_T1 , newton_complex_step_rel_T0 , newton_complex_step_rel_T1 private impure subroutine newton_rel_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine newton_rel_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine newton_complex_step_rel_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine newton_complex_step_rel_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Source Code type :: nlsolver character (:), allocatable :: lin_method character (:), allocatable :: nl_method character (:), allocatable :: fdm_method real ( rk ) :: TolFun real ( rk ) :: fdm_tol real ( rk ) :: cs_tol integer :: maxit integer :: nmp integer :: verbosity ! character(:), allocatable :: stepsize ! real(rk)                  :: alpha0 ! real(rk)                  :: c1 ! real(rk)                  :: c2 contains procedure :: set_options procedure :: newton_rel_T0 procedure :: newton_rel_T1 procedure :: newton_complex_step_rel_T0 procedure :: newton_complex_step_rel_T1 generic :: solve => newton_rel_T0 ,& newton_rel_T1 ,& newton_complex_step_rel_T0 ,& newton_complex_step_rel_T1 final :: deallocate_solver end type nlsolver","tags":"","loc":"type/nlsolver.html"},{"title":"gesv – forsolver","text":"public interface gesv Called by interface~~gesv~~CalledByGraph interface~gesv external_interfaces_solver::gesv proc~gesv_rel forsolver::gesv_rel proc~gesv_rel->interface~gesv proc~solver_lin forsolver::solver_lin proc~solver_lin->proc~gesv_rel interface~solve forsolver::solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine sgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo","tags":"","loc":"interface/gesv.html"},{"title":"gels – forsolver","text":"public interface gels Called by interface~~gels~~CalledByGraph interface~gels external_interfaces_solver::gels proc~gels_rel forsolver::gels_rel proc~gels_rel->interface~gels proc~solver_lin forsolver::solver_lin proc~solver_lin->proc~gels_rel interface~solve forsolver::solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine sgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo","tags":"","loc":"interface/gels.html"},{"title":"solver_lin – forsolver","text":"private pure function solver_lin(A, b, method) result(x) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2))) Calls proc~~solver_lin~~CallsGraph proc~solver_lin forsolver::solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~solver_lin~~CalledByGraph proc~solver_lin forsolver::solver_lin interface~solve forsolver::solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function solver_lin ( A , b , method ) result ( x ) ! inputs real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b character ( * ), optional , intent ( in ) :: method ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))) :: x ! solution matrix x ! local variables integer :: info ! result info ! call solver if ( present ( method )) then select case ( method ) case ( 'gesv' ) call gesv_rel ( A , b , x , info ) case ( 'gels' ) call gels_rel ( A , b , x , info ) end select else if ( size ( A , 1 ) == size ( A , 2 )) then call gesv_rel ( A , b , x , info ) else call gels_rel ( A , b , x , info ) end if end if end function solver_lin","tags":"","loc":"proc/solver_lin.html"},{"title":"gesv_rel – forsolver","text":"private pure subroutine gesv_rel(A, b, x, info) Uses external_interfaces_solver proc~~gesv_rel~~UsesGraph proc~gesv_rel forsolver::gesv_rel module~external_interfaces_solver external_interfaces_solver proc~gesv_rel->module~external_interfaces_solver kinds kinds module~external_interfaces_solver->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info Calls proc~~gesv_rel~~CallsGraph proc~gesv_rel forsolver::gesv_rel interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gesv_rel~~CalledByGraph proc~gesv_rel forsolver::gesv_rel proc~solver_lin forsolver::solver_lin proc~solver_lin->proc~gesv_rel interface~solve forsolver::solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine gesv_rel ( A , b , x , info ) use external_interfaces_solver ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables integer :: n , lda , ldb , nrhs integer , dimension ( size ( A , 2 )) :: ipiv real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! get dimensions nrhs = 1 ! size(b, 2) n = size ( A , 2 ) lda = max ( 1 , n ) ldb = max ( 1 , n ) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! call gels subroutine call gesv ( n , nrhs , a_copy , lda , ipiv , b_copy , ldb , info ) ! copy the solution matrix if ( info == 0 ) then x = b_copy ( 1 : ldb , 1 ) ! nrhs = 1 else error stop 'gesv failed' end if end subroutine gesv_rel","tags":"","loc":"proc/gesv_rel.html"},{"title":"gels_rel – forsolver","text":"private pure subroutine gels_rel(A, b, x, info) Uses external_interfaces_solver proc~~gels_rel~~UsesGraph proc~gels_rel forsolver::gels_rel module~external_interfaces_solver external_interfaces_solver proc~gels_rel->module~external_interfaces_solver kinds kinds module~external_interfaces_solver->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. solves an overdetermined or underdetermined linear system using gels. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info Calls proc~~gels_rel~~CallsGraph proc~gels_rel forsolver::gels_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gels_rel~~CalledByGraph proc~gels_rel forsolver::gels_rel proc~solver_lin forsolver::solver_lin proc~solver_lin->proc~gels_rel interface~solve forsolver::solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine gels_rel ( A , b , x , info ) use external_interfaces_solver ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables character ( 1 ) :: trans integer :: m , n , lda , ldb , lwork , nrhs real ( rk ), allocatable :: work (:) real ( rk ) :: work1 ( 1 ) real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! trans = 'n' ! get dimensions nrhs = 1 ! size(b, 2) m = size ( A , 1 ) n = size ( A , 2 ) lda = max ( 1 , m ) ldb = max ( 1 , max ( m , n )) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! calculate the optimal size of the work array call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work1 , - 1 , info ) ! allocate work array lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) ! call gels subroutine call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work , lwork , info ) ! copy the solution matrix if ( info == 0 ) then if ( trans == 'n' ) x = b_copy ( 1 : n , 1 ) ! nrhs = 1 if ( trans == 't' ) x = b_copy ( 1 : m , 1 ) ! nrhs = 1 else error stop 'gels failed' end if ! deallocate workspace deallocate ( work ) end subroutine gels_rel","tags":"","loc":"proc/gels_rel.html"},{"title":"newton_rel_T0 – forsolver","text":"private impure subroutine newton_rel_T0(this, F, dFdx, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Calls proc~~newton_rel_t0~~CallsGraph proc~newton_rel_t0 forsolver::nlsolver%newton_rel_T0 proc~modified_newton_method_t0 forsolver::modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 forsolver::modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 forsolver::newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 forsolver::quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 derivative derivative proc~modified_quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_rel_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun1 ( x ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: Fun1 end function Fun1 impure function dFun1 ( x ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: dFun1 end function dFun1 end interface procedure ( Fun1 ) :: F procedure ( dFun1 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , x0 , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)         dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) !  case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) !  case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_rel_T0","tags":"","loc":"proc/newton_rel_t0.html"},{"title":"newton_rel_T1 – forsolver","text":"private impure subroutine newton_rel_T1(this, F, dFdx, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~newton_rel_t1~~CallsGraph proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve forsolver::solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_rel_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun2 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun2 impure function dFun2 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun2 end interface procedure ( Fun2 ) :: F procedure ( dFun2 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) ! case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) ! case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , x_sol ( i ) end do end if end subroutine newton_rel_T1","tags":"","loc":"proc/newton_rel_t1.html"},{"title":"newton_complex_step_rel_T0 – forsolver","text":"private impure subroutine newton_complex_step_rel_T0(this, F, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol Calls proc~~newton_complex_step_rel_t0~~CallsGraph proc~newton_complex_step_rel_t0 forsolver::nlsolver%newton_complex_step_rel_T0 proc~modified_quasi_cs_newton_method_t0 forsolver::modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 forsolver::quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_complex_step_rel_T0 ( this , F , x0 , x_sol ) interface impure function Fun3 ( x ) result ( res ) import rk complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun3 end interface procedure ( Fun3 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , real ( x0 , kind = rk ), this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)        dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_complex_step_rel_T0","tags":"","loc":"proc/newton_complex_step_rel_t0.html"},{"title":"newton_complex_step_rel_T1 – forsolver","text":"private impure subroutine newton_complex_step_rel_T1(this, F, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~newton_complex_step_rel_t1~~CallsGraph proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 derivative derivative proc~modified_quasi_cs_newton_method_t1->derivative interface~solve forsolver::solve proc~modified_quasi_cs_newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_complex_step_rel_T1 ( this , F , x0 , x_sol ) interface impure function Fun4 ( x ) result ( res ) import rk complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun4 end interface procedure ( Fun4 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, f12.8, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , real ( x_sol ( i ), kind = rk ) end do ! print '(a, g0)', 'x_sol = ', x_sol end if end subroutine newton_complex_step_rel_T1","tags":"","loc":"proc/newton_complex_step_rel_t1.html"},{"title":"set_options – forsolver","text":"private impure subroutine set_options(this, nl_method, lin_method, maxit, TolFun, alpha0, c1, c2, nmp, fdm_method, fdm_tol, cs_tol, stepsize, verbosity) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this character(len=*), intent(in), optional :: nl_method character(len=*), intent(in), optional :: lin_method integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: TolFun real(kind=rk), intent(in), optional :: alpha0 real(kind=rk), intent(in), optional :: c1 real(kind=rk), intent(in), optional :: c2 integer, intent(in), optional :: nmp character(len=*), intent(in), optional :: fdm_method real(kind=rk), intent(in), optional :: fdm_tol real(kind=rk), intent(in), optional :: cs_tol character(len=*), intent(in), optional :: stepsize integer, intent(in), optional :: verbosity Source Code impure subroutine set_options ( this ,& nl_method , lin_method , maxit , TolFun , alpha0 , c1 , c2 , nmp , fdm_method , fdm_tol , cs_tol , stepsize , verbosity ) class ( nlsolver ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: nl_method character ( * ), intent ( in ), optional :: lin_method character ( * ), intent ( in ), optional :: stepsize character ( * ), intent ( in ), optional :: fdm_method real ( rk ), intent ( in ), optional :: TolFun real ( rk ), intent ( in ), optional :: fdm_tol real ( rk ), intent ( in ), optional :: cs_tol integer , intent ( in ), optional :: maxit real ( rk ), intent ( in ), optional :: alpha0 real ( rk ), intent ( in ), optional :: c1 real ( rk ), intent ( in ), optional :: c2 integer , intent ( in ), optional :: nmp integer , intent ( in ), optional :: verbosity if ( present ( nl_method )) then this % nl_method = nl_method else this % nl_method = 'newton' end if if ( present ( lin_method )) then this % lin_method = lin_method else this % lin_method = 'gels' end if if ( present ( fdm_method )) then this % fdm_method = fdm_method else this % fdm_method = 'forward' end if if ( present ( maxit )) then this % maxit = maxit else this % maxit = 100 end if if ( present ( TolFun )) then this % TolFun = TolFun else this % TolFun = 1e-4_rk end if if ( present ( fdm_tol )) then this % fdm_tol = fdm_tol else this % fdm_tol = 1e-4_rk end if if ( present ( cs_tol )) then this % cs_tol = cs_tol else this % cs_tol = 1e-100_rk end if if ( present ( nmp )) then this % nmp = nmp else this % nmp = 2 end if if ( present ( verbosity )) then this % verbosity = verbosity else this % verbosity = 1 end if ! if (present(stepsize))   this%stepsize   = stepsize ! if (present(alpha0))     this%alpha0     = alpha0 ! if (present(c1))         this%c1         = c1 ! if (present(c2))         this%c2         = c2 end subroutine set_options","tags":"","loc":"proc/set_options.html"},{"title":"deallocate_solver – forsolver","text":"private pure elemental subroutine deallocate_solver(this) Arguments Type Intent Optional Attributes Name type( nlsolver ), intent(inout) :: this Source Code elemental pure subroutine deallocate_solver ( this ) type ( nlsolver ), intent ( inout ) :: this if ( allocated ( this % nl_method )) deallocate ( this % nl_method ) if ( allocated ( this % fdm_method )) deallocate ( this % fdm_method ) end subroutine deallocate_solver","tags":"","loc":"proc/deallocate_solver.html"},{"title":"newton_method_T0 – forsolver","text":"private impure subroutine newton_method_T0(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun5) :: F procedure(dFun5) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Called by proc~~newton_method_t0~~CalledByGraph proc~newton_method_t0 forsolver::newton_method_T0 proc~newton_rel_t0 forsolver::nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~newton_method_t0 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun5 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun5 impure function dFun5 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun5 end interface procedure ( Fun5 ) :: F procedure ( dFun5 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T0","tags":"","loc":"proc/newton_method_t0.html"},{"title":"modified_newton_method_T0 – forsolver","text":"private impure subroutine modified_newton_method_T0(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun6) :: F procedure(dFun6) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Called by proc~~modified_newton_method_t0~~CalledByGraph proc~modified_newton_method_t0 forsolver::modified_newton_method_T0 proc~newton_rel_t0 forsolver::nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun6 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun6 impure function dFun6 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun6 end interface procedure ( Fun6 ) :: F procedure ( dFun6 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T0","tags":"","loc":"proc/modified_newton_method_t0.html"},{"title":"quasi_fd_newton_method_T0 – forsolver","text":"private impure subroutine quasi_fd_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun7) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Calls proc~~quasi_fd_newton_method_t0~~CallsGraph proc~quasi_fd_newton_method_t0 forsolver::quasi_fd_newton_method_T0 derivative derivative proc~quasi_fd_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_fd_newton_method_t0~~CalledByGraph proc~quasi_fd_newton_method_t0 forsolver::quasi_fd_newton_method_T0 proc~newton_rel_t0 forsolver::nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun7 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun7 end interface procedure ( Fun7 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T0","tags":"","loc":"proc/quasi_fd_newton_method_t0.html"},{"title":"modified_quasi_fd_newton_method_T0 – forsolver","text":"private impure subroutine modified_quasi_fd_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun8) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Calls proc~~modified_quasi_fd_newton_method_t0~~CallsGraph proc~modified_quasi_fd_newton_method_t0 forsolver::modified_quasi_fd_newton_method_T0 derivative derivative proc~modified_quasi_fd_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_fd_newton_method_t0~~CalledByGraph proc~modified_quasi_fd_newton_method_t0 forsolver::modified_quasi_fd_newton_method_T0 proc~newton_rel_t0 forsolver::nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun8 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun8 end interface procedure ( Fun8 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T0","tags":"","loc":"proc/modified_quasi_fd_newton_method_t0.html"},{"title":"newton_method_T1 – forsolver","text":"private impure subroutine newton_method_T1(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun9) :: F procedure(dFun10) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~newton_method_t1~~CallsGraph proc~newton_method_t1 forsolver::newton_method_T1 interface~solve forsolver::solve proc~newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newton_method_t1~~CalledByGraph proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun9 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun9 impure function dFun10 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun10 end interface procedure ( Fun9 ) :: F procedure ( dFun10 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T1","tags":"","loc":"proc/newton_method_t1.html"},{"title":"modified_newton_method_T1 – forsolver","text":"private impure subroutine modified_newton_method_T1(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun11) :: F procedure(dFun11) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~modified_newton_method_t1~~CallsGraph proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 interface~solve forsolver::solve proc~modified_newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_newton_method_t1~~CalledByGraph proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun11 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun11 impure function dFun11 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun11 end interface procedure ( Fun11 ) :: F procedure ( dFun11 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T1","tags":"","loc":"proc/modified_newton_method_t1.html"},{"title":"quasi_fd_newton_method_T1 – forsolver","text":"private impure subroutine quasi_fd_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun12) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~quasi_fd_newton_method_t1~~CallsGraph proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 derivative derivative proc~quasi_fd_newton_method_t1->derivative interface~solve forsolver::solve proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_fd_newton_method_t1~~CalledByGraph proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun12 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun12 end interface procedure ( Fun12 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T1","tags":"","loc":"proc/quasi_fd_newton_method_t1.html"},{"title":"modified_quasi_fd_newton_method_T1 – forsolver","text":"private impure subroutine modified_quasi_fd_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun13) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~modified_quasi_fd_newton_method_t1~~CallsGraph proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 derivative derivative proc~modified_quasi_fd_newton_method_t1->derivative interface~solve forsolver::solve proc~modified_quasi_fd_newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_fd_newton_method_t1~~CalledByGraph proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun13 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun13 end interface procedure ( Fun13 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T1","tags":"","loc":"proc/modified_quasi_fd_newton_method_t1.html"},{"title":"quasi_cs_newton_method_T0 – forsolver","text":"private impure subroutine quasi_cs_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun14) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol Calls proc~~quasi_cs_newton_method_t0~~CallsGraph proc~quasi_cs_newton_method_t0 forsolver::quasi_cs_newton_method_T0 derivative derivative proc~quasi_cs_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_cs_newton_method_t0~~CalledByGraph proc~quasi_cs_newton_method_t0 forsolver::quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0 forsolver::nlsolver%newton_complex_step_rel_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun14 ( x ) result ( res ) import rk complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun14 end interface procedure ( Fun14 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T0","tags":"","loc":"proc/quasi_cs_newton_method_t0.html"},{"title":"modified_quasi_cs_newton_method_T0 – forsolver","text":"private impure subroutine modified_quasi_cs_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun15) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol Calls proc~~modified_quasi_cs_newton_method_t0~~CallsGraph proc~modified_quasi_cs_newton_method_t0 forsolver::modified_quasi_cs_newton_method_T0 derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_cs_newton_method_t0~~CalledByGraph proc~modified_quasi_cs_newton_method_t0 forsolver::modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0 forsolver::nlsolver%newton_complex_step_rel_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun15 ( x ) result ( res ) import rk complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun15 end interface procedure ( Fun15 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T0","tags":"","loc":"proc/modified_quasi_cs_newton_method_t0.html"},{"title":"quasi_cs_newton_method_T1 – forsolver","text":"private impure subroutine quasi_cs_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun16) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~quasi_cs_newton_method_t1~~CallsGraph proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 derivative derivative proc~quasi_cs_newton_method_t1->derivative interface~solve forsolver::solve proc~quasi_cs_newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_cs_newton_method_t1~~CalledByGraph proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun16 ( x ) result ( res ) import rk complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun16 end interface procedure ( Fun16 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T1","tags":"","loc":"proc/quasi_cs_newton_method_t1.html"},{"title":"modified_quasi_cs_newton_method_T1 – forsolver","text":"private impure subroutine modified_quasi_cs_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun17) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~modified_quasi_cs_newton_method_t1~~CallsGraph proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 derivative derivative proc~modified_quasi_cs_newton_method_t1->derivative interface~solve forsolver::solve proc~modified_quasi_cs_newton_method_t1->interface~solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_cs_newton_method_t1~~CalledByGraph proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun17 ( x ) result ( res ) import rk complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun17 end interface procedure ( Fun17 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T1","tags":"","loc":"proc/modified_quasi_cs_newton_method_t1.html"},{"title":"solve – forsolver","text":"public interface solve Calls interface~~solve~~CallsGraph interface~solve forsolver::solve proc~solver_lin forsolver::solver_lin interface~solve->proc~solver_lin proc~gels_rel forsolver::gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel forsolver::gesv_rel proc~solver_lin->proc~gesv_rel interface~gels external_interfaces_solver::gels proc~gels_rel->interface~gels interface~gesv external_interfaces_solver::gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~solve~~CalledByGraph interface~solve forsolver::solve proc~modified_newton_method_t1 forsolver::modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 forsolver::modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 forsolver::modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 forsolver::newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 forsolver::quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 forsolver::quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve proc~newton_complex_step_rel_t1 forsolver::nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 forsolver::nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function solver_lin (A, b, method) result(x) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2)))","tags":"","loc":"interface/solve.html"},{"title":"external_interfaces_solver – forsolver","text":"Uses kinds module~~external_interfaces_solver~~UsesGraph module~external_interfaces_solver external_interfaces_solver kinds kinds module~external_interfaces_solver->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~external_interfaces_solver~~UsedByGraph module~external_interfaces_solver external_interfaces_solver proc~gels_rel forsolver::gels_rel proc~gels_rel->module~external_interfaces_solver proc~gesv_rel forsolver::gesv_rel proc~gesv_rel->module~external_interfaces_solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface gesv public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine sgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public        interface gels public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine sgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo","tags":"","loc":"module/external_interfaces_solver.html"},{"title":"forsolver – forsolver","text":"Uses fordiff kinds module~~forsolver~~UsesGraph module~forsolver forsolver fordiff fordiff module~forsolver->fordiff kinds kinds module~forsolver->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface solve private pure function solver_lin (A, b, method) result(x) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2))) Derived Types type, public :: nlsolver Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: lin_method character(len=:), public, allocatable :: nl_method character(len=:), public, allocatable :: fdm_method real(kind=rk), public :: TolFun real(kind=rk), public :: fdm_tol real(kind=rk), public :: cs_tol integer, public :: maxit integer, public :: nmp integer, public :: verbosity Finalizations Procedures final :: deallocate_solver Type-Bound Procedures procedure, public :: set_options procedure, public :: newton_rel_T0 procedure, public :: newton_rel_T1 procedure, public :: newton_complex_step_rel_T0 procedure, public :: newton_complex_step_rel_T1 generic, public :: solve => newton_rel_T0 , newton_rel_T1 , newton_complex_step_rel_T0 , newton_complex_step_rel_T1 Functions private pure function solver_lin (A, b, method) result(x) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2))) Subroutines private pure subroutine gesv_rel (A, b, x, info) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info private pure subroutine gels_rel (A, b, x, info) Author Seyed Ali Ghasemi solves an overdetermined or underdetermined linear system using gels. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info private impure subroutine newton_rel_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine newton_rel_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine newton_complex_step_rel_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine newton_complex_step_rel_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine set_options (this, nl_method, lin_method, maxit, TolFun, alpha0, c1, c2, nmp, fdm_method, fdm_tol, cs_tol, stepsize, verbosity) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this character(len=*), intent(in), optional :: nl_method character(len=*), intent(in), optional :: lin_method integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: TolFun real(kind=rk), intent(in), optional :: alpha0 real(kind=rk), intent(in), optional :: c1 real(kind=rk), intent(in), optional :: c2 integer, intent(in), optional :: nmp character(len=*), intent(in), optional :: fdm_method real(kind=rk), intent(in), optional :: fdm_tol real(kind=rk), intent(in), optional :: cs_tol character(len=*), intent(in), optional :: stepsize integer, intent(in), optional :: verbosity private pure elemental subroutine deallocate_solver (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name type( nlsolver ), intent(inout) :: this private impure subroutine newton_method_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun5) :: F procedure(dFun5) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine modified_newton_method_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun6) :: F procedure(dFun6) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine quasi_fd_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun7) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine modified_quasi_fd_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun8) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine newton_method_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun9) :: F procedure(dFun10) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine modified_newton_method_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun11) :: F procedure(dFun11) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine quasi_fd_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun12) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine modified_quasi_fd_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun13) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine quasi_cs_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun14) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine modified_quasi_cs_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun15) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine quasi_cs_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun16) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine modified_quasi_cs_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun17) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol","tags":"","loc":"module/forsolver.html"},{"title":"external_interfaces.f90 – forsolver","text":"Files dependent on this one sourcefile~~external_interfaces.f90~~AfferentGraph sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module external_interfaces_solver use kinds implicit none interface gesv #if defined(REAL64) pure subroutine dgesv ( fn , fnrhs , fa , flda , fipiv , fb , fldb , finfo ) import rk integer , intent ( in ) :: fn , fnrhs , flda , fldb real ( rk ), intent ( inout ) :: fa ( flda , fn ), fb ( fldb , fnrhs ) integer , intent ( out ) :: finfo integer , intent ( out ) :: fipiv ( fn ) end subroutine dgesv #elif defined(REAL32) pure subroutine sgesv ( fn , fnrhs , fa , flda , fipiv , fb , fldb , finfo ) import rk integer , intent ( in ) :: fn , fnrhs , flda , fldb real ( rk ), intent ( inout ) :: fa ( flda , fn ), fb ( fldb , fnrhs ) integer , intent ( out ) :: finfo integer , intent ( out ) :: fipiv ( fn ) end subroutine sgesv #else pure subroutine dgesv ( fn , fnrhs , fa , flda , fipiv , fb , fldb , finfo ) import rk integer , intent ( in ) :: fn , fnrhs , flda , fldb real ( rk ), intent ( inout ) :: fa ( flda , fn ), fb ( fldb , fnrhs ) integer , intent ( out ) :: finfo integer , intent ( out ) :: fipiv ( fn ) end subroutine dgesv #endif end interface interface gels #if defined(REAL64) pure subroutine dgels ( ftrans , fm , fn , fnrhs , fa , flda , fb , fldb , fwork , flwork , finfo ) import :: rk character ( len = 1 ), intent ( in ) :: ftrans integer , intent ( in ) :: fm , fn , fnrhs , flda , fldb , flwork real ( rk ), intent ( inout ) :: fa ( flda , * ), fb ( fldb , * ) real ( rk ), intent ( in ) :: fwork ( * ) integer , intent ( out ) :: finfo end subroutine dgels #elif defined(REAL32) pure subroutine sgels ( ftrans , fm , fn , fnrhs , fa , flda , fb , fldb , fwork , flwork , finfo ) import :: rk character ( len = 1 ), intent ( in ) :: ftrans integer , intent ( in ) :: fm , fn , fnrhs , flda , fldb , flwork real ( rk ), intent ( inout ) :: fa ( flda , * ), fb ( fldb , * ) real ( rk ), intent ( in ) :: fwork ( * ) integer , intent ( out ) :: finfo end subroutine sgels #else pure subroutine dgels ( ftrans , fm , fn , fnrhs , fa , flda , fb , fldb , fwork , flwork , finfo ) import :: rk character ( len = 1 ), intent ( in ) :: ftrans integer , intent ( in ) :: fm , fn , fnrhs , flda , fldb , flwork real ( rk ), intent ( inout ) :: fa ( flda , * ), fb ( fldb , * ) real ( rk ), intent ( in ) :: fwork ( * ) integer , intent ( out ) :: finfo end subroutine dgels #endif end interface end module external_interfaces_solver","tags":"","loc":"sourcefile/external_interfaces.f90.html"},{"title":"forsolver.f90 – forsolver","text":"This file depends on sourcefile~~forsolver.f90~~EfferentGraph sourcefile~forsolver.f90 forsolver.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forsolver ! This module provides functions and subroutines for ! solving linear systems and performing Newton's method. use kinds use fordiff implicit none private public :: solve , nlsolver type :: nlsolver character (:), allocatable :: lin_method character (:), allocatable :: nl_method character (:), allocatable :: fdm_method real ( rk ) :: TolFun real ( rk ) :: fdm_tol real ( rk ) :: cs_tol integer :: maxit integer :: nmp integer :: verbosity ! character(:), allocatable :: stepsize ! real(rk)                  :: alpha0 ! real(rk)                  :: c1 ! real(rk)                  :: c2 contains procedure :: set_options procedure :: newton_rel_T0 procedure :: newton_rel_T1 procedure :: newton_complex_step_rel_T0 procedure :: newton_complex_step_rel_T1 generic :: solve => newton_rel_T0 ,& newton_rel_T1 ,& newton_complex_step_rel_T0 ,& newton_complex_step_rel_T1 final :: deallocate_solver end type nlsolver !=============================================================================== interface solve procedure :: solver_lin end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi pure function solver_lin ( A , b , method ) result ( x ) ! inputs real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b character ( * ), optional , intent ( in ) :: method ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))) :: x ! solution matrix x ! local variables integer :: info ! result info ! call solver if ( present ( method )) then select case ( method ) case ( 'gesv' ) call gesv_rel ( A , b , x , info ) case ( 'gels' ) call gels_rel ( A , b , x , info ) end select else if ( size ( A , 1 ) == size ( A , 2 )) then call gesv_rel ( A , b , x , info ) else call gels_rel ( A , b , x , info ) end if end if end function solver_lin !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine gesv_rel ( A , b , x , info ) use external_interfaces_solver ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables integer :: n , lda , ldb , nrhs integer , dimension ( size ( A , 2 )) :: ipiv real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! get dimensions nrhs = 1 ! size(b, 2) n = size ( A , 2 ) lda = max ( 1 , n ) ldb = max ( 1 , n ) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! call gels subroutine call gesv ( n , nrhs , a_copy , lda , ipiv , b_copy , ldb , info ) ! copy the solution matrix if ( info == 0 ) then x = b_copy ( 1 : ldb , 1 ) ! nrhs = 1 else error stop 'gesv failed' end if end subroutine gesv_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> solves an overdetermined or underdetermined linear system using gels. pure subroutine gels_rel ( A , b , x , info ) use external_interfaces_solver ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables character ( 1 ) :: trans integer :: m , n , lda , ldb , lwork , nrhs real ( rk ), allocatable :: work (:) real ( rk ) :: work1 ( 1 ) real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! trans = 'n' ! get dimensions nrhs = 1 ! size(b, 2) m = size ( A , 1 ) n = size ( A , 2 ) lda = max ( 1 , m ) ldb = max ( 1 , max ( m , n )) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! calculate the optimal size of the work array call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work1 , - 1 , info ) ! allocate work array lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) ! call gels subroutine call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work , lwork , info ) ! copy the solution matrix if ( info == 0 ) then if ( trans == 'n' ) x = b_copy ( 1 : n , 1 ) ! nrhs = 1 if ( trans == 't' ) x = b_copy ( 1 : m , 1 ) ! nrhs = 1 else error stop 'gels failed' end if ! deallocate workspace deallocate ( work ) end subroutine gels_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_rel_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun1 ( x ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: Fun1 end function Fun1 impure function dFun1 ( x ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: dFun1 end function dFun1 end interface procedure ( Fun1 ) :: F procedure ( dFun1 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , x0 , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)         dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) !  case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) !  case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_rel_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_rel_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun2 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun2 impure function dFun2 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun2 end interface procedure ( Fun2 ) :: F procedure ( dFun2 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) ! case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) ! case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , x_sol ( i ) end do end if end subroutine newton_rel_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_complex_step_rel_T0 ( this , F , x0 , x_sol ) interface impure function Fun3 ( x ) result ( res ) import rk complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun3 end interface procedure ( Fun3 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , real ( x0 , kind = rk ), this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)        dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_complex_step_rel_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_complex_step_rel_T1 ( this , F , x0 , x_sol ) interface impure function Fun4 ( x ) result ( res ) import rk complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun4 end interface procedure ( Fun4 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, f12.8, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , real ( x_sol ( i ), kind = rk ) end do ! print '(a, g0)', 'x_sol = ', x_sol end if end subroutine newton_complex_step_rel_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine set_options ( this ,& nl_method , lin_method , maxit , TolFun , alpha0 , c1 , c2 , nmp , fdm_method , fdm_tol , cs_tol , stepsize , verbosity ) class ( nlsolver ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: nl_method character ( * ), intent ( in ), optional :: lin_method character ( * ), intent ( in ), optional :: stepsize character ( * ), intent ( in ), optional :: fdm_method real ( rk ), intent ( in ), optional :: TolFun real ( rk ), intent ( in ), optional :: fdm_tol real ( rk ), intent ( in ), optional :: cs_tol integer , intent ( in ), optional :: maxit real ( rk ), intent ( in ), optional :: alpha0 real ( rk ), intent ( in ), optional :: c1 real ( rk ), intent ( in ), optional :: c2 integer , intent ( in ), optional :: nmp integer , intent ( in ), optional :: verbosity if ( present ( nl_method )) then this % nl_method = nl_method else this % nl_method = 'newton' end if if ( present ( lin_method )) then this % lin_method = lin_method else this % lin_method = 'gels' end if if ( present ( fdm_method )) then this % fdm_method = fdm_method else this % fdm_method = 'forward' end if if ( present ( maxit )) then this % maxit = maxit else this % maxit = 100 end if if ( present ( TolFun )) then this % TolFun = TolFun else this % TolFun = 1e-4_rk end if if ( present ( fdm_tol )) then this % fdm_tol = fdm_tol else this % fdm_tol = 1e-4_rk end if if ( present ( cs_tol )) then this % cs_tol = cs_tol else this % cs_tol = 1e-100_rk end if if ( present ( nmp )) then this % nmp = nmp else this % nmp = 2 end if if ( present ( verbosity )) then this % verbosity = verbosity else this % verbosity = 1 end if ! if (present(stepsize))   this%stepsize   = stepsize ! if (present(alpha0))     this%alpha0     = alpha0 ! if (present(c1))         this%c1         = c1 ! if (present(c2))         this%c2         = c2 end subroutine set_options !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine deallocate_solver ( this ) type ( nlsolver ), intent ( inout ) :: this if ( allocated ( this % nl_method )) deallocate ( this % nl_method ) if ( allocated ( this % fdm_method )) deallocate ( this % fdm_method ) end subroutine deallocate_solver !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun5 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun5 impure function dFun5 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun5 end interface procedure ( Fun5 ) :: F procedure ( dFun5 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun6 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun6 impure function dFun6 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun6 end interface procedure ( Fun6 ) :: F procedure ( dFun6 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun7 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun7 end interface procedure ( Fun7 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun8 ( x ) result ( res ) import rk real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun8 end interface procedure ( Fun8 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun9 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun9 impure function dFun10 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun10 end interface procedure ( Fun9 ) :: F procedure ( dFun10 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun11 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun11 impure function dFun11 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun11 end interface procedure ( Fun11 ) :: F procedure ( dFun11 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun12 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun12 end interface procedure ( Fun12 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun13 ( x ) result ( res ) import rk real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun13 end interface procedure ( Fun13 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun14 ( x ) result ( res ) import rk complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun14 end interface procedure ( Fun14 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun15 ( x ) result ( res ) import rk complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun15 end interface procedure ( Fun15 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun16 ( x ) result ( res ) import rk complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun16 end interface procedure ( Fun16 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun17 ( x ) result ( res ) import rk complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun17 end interface procedure ( Fun17 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T1 !=============================================================================== end module forsolver","tags":"","loc":"sourcefile/forsolver.f90.html"}]}