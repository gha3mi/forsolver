var tipuesearch = {"pages":[{"title":" ForSolver ","text":"ForSolver ForSolver : A Fortran library of linear and nonlinear solvers. Usage Linear system solver use forsolver , only : solve x = solve ( A , b , method ) available methods (optional): gesv gels Nonlinear system solver use forsolver , only : nlsolver call nls % set_options (& lin_method ,& nl_method ,& fdm_method ,& fdm_tol ,& cs_tol ,& TolFun ,& maxit ,& nmp ,& verbosity ) call nls % solve ( F , dFdx , x0 , x_sol ) available nl_methods: newton newton-modified newton-quasi-fd newton-quasi-fd-modified newton-quasi-cs newton-quasi-cs-modified fd: finite difference method cs: complex step method Requirements A Fortran Compiler LAPACK, BLAS or MKL Fortran Package Manager (fpm) fpm Dependency If you want to use ForSolver as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forsolver = { git = \"https://github.com/gha3mi/forsolver.git\" } Examples Example 1: Linear System Solver program example1 use kinds use forsolver implicit none real ( rk ), dimension (:,:), allocatable :: A real ( rk ), dimension (:) , allocatable :: x , b integer :: m , n , i , j m = 3 n = 2 allocate ( A ( m , n ), b ( m ), x ( n )) A ( 1 ,:) = [ 1.0_rk , 5.0_rk ] A ( 2 ,:) = [ 3.0_rk , 1.0_rk ] A ( 3 ,:) = [ - 2.0_rk , 4.0_rk ] b = [ 4.0_rk , - 2.0_rk , 3.0_rk ] x = solve ( A , b ) end program example1 Example 2: Newton's Method for Root Finding module my_function3 use kinds implicit none contains function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1 function dF1dx ( x ) result ( dFdx_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: dFdx_val dFdx_val = 1 5.0_rk * x ** 2 + 8.0_rk end function dF1dx end module my_function3 program example2 use forsolver use my_function3 implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x call nls % set_options (& nl_method = 'newton' ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 1 ) call nls % solve ( F = F1 , dFdx = dF1dx , x0 = 1 0.0_rk , x_sol = x ) end program example2 CI Status API Documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForSolver using ford run the following\ncommand: ford README.md Contributing Contributions to ForSolver are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"nlsolver – ForSolver ","text":"type, public :: nlsolver Components Type Visibility Attributes Name Initial real(kind=rk), public :: TolFun real(kind=rk), public :: cs_tol character(len=:), public, allocatable :: fdm_method real(kind=rk), public :: fdm_tol character(len=:), public, allocatable :: lin_method integer, public :: maxit character(len=:), public, allocatable :: nl_method integer, public :: nmp integer, public :: verbosity Finalization Procedures final :: deallocate_solver private pure elemental subroutine deallocate_solver (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name type( nlsolver ), intent(inout) :: this Type-Bound Procedures procedure, public :: newton_complex_step_rel_T0 private impure subroutine newton_complex_step_rel_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol procedure, public :: newton_complex_step_rel_T1 private impure subroutine newton_complex_step_rel_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol procedure, public :: newton_rel_T0 private impure subroutine newton_rel_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol procedure, public :: newton_rel_T1 private impure subroutine newton_rel_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol procedure, public :: set_options private impure subroutine set_options (this, nl_method, lin_method, maxit, TolFun, alpha0, c1, c2, nmp, fdm_method, fdm_tol, cs_tol, stepsize, verbosity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this character(len=*), intent(in), optional :: nl_method character(len=*), intent(in), optional :: lin_method integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: TolFun real(kind=rk), intent(in), optional :: alpha0 real(kind=rk), intent(in), optional :: c1 real(kind=rk), intent(in), optional :: c2 integer, intent(in), optional :: nmp character(len=*), intent(in), optional :: fdm_method real(kind=rk), intent(in), optional :: fdm_tol real(kind=rk), intent(in), optional :: cs_tol character(len=*), intent(in), optional :: stepsize integer, intent(in), optional :: verbosity generic, public :: solve => newton_rel_T0 , newton_rel_T1 , newton_complex_step_rel_T0 , newton_complex_step_rel_T1 private impure subroutine newton_rel_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine newton_rel_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine newton_complex_step_rel_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine newton_complex_step_rel_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Source Code type :: nlsolver character (:), allocatable :: lin_method character (:), allocatable :: nl_method character (:), allocatable :: fdm_method real ( rk ) :: TolFun real ( rk ) :: fdm_tol real ( rk ) :: cs_tol integer :: maxit integer :: nmp integer :: verbosity ! character(:), allocatable :: stepsize ! real(rk)                  :: alpha0 ! real(rk)                  :: c1 ! real(rk)                  :: c2 contains procedure :: set_options procedure :: newton_rel_T0 procedure :: newton_rel_T1 procedure :: newton_complex_step_rel_T0 procedure :: newton_complex_step_rel_T1 generic :: solve => newton_rel_T0 ,& newton_rel_T1 ,& newton_complex_step_rel_T0 ,& newton_complex_step_rel_T1 final :: deallocate_solver end type nlsolver","tags":"","url":"type/nlsolver.html"},{"title":"F4 – ForSolver","text":"public  function F4(x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in), dimension(:) :: x Return Value complex(kind=rk), dimension(:), allocatable Source Code function F4 ( x ) result ( F_val ) complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F4","tags":"","url":"proc/f4.html"},{"title":"F2 – ForSolver","text":"public  function F2(x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x Return Value complex(kind=rk) Source Code function F2 ( x ) result ( F_val ) complex ( rk ), intent ( in ) :: x complex ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F2","tags":"","url":"proc/f2.html"},{"title":"F1 – ForSolver","text":"public  function F1(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) Source Code function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1","tags":"","url":"proc/f1.html"},{"title":"dF1dx – ForSolver","text":"public  function dF1dx(x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) Source Code function dF1dx ( x ) result ( dFdx_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: dFdx_val dFdx_val = 1 5.0_rk * x ** 2 + 8.0_rk end function dF1dx","tags":"","url":"proc/df1dx.html"},{"title":"F1 – ForSolver","text":"public  function F1(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) Source Code function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1","tags":"","url":"proc/f1~2.html"},{"title":"dF1dx – ForSolver","text":"public  function dF1dx(x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) Source Code function dF1dx ( x ) result ( dFdx_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: dFdx_val dFdx_val = 1 5.0_rk * x ** 2 + 8.0_rk end function dF1dx","tags":"","url":"proc/df1dx~2.html"},{"title":"F4 – ForSolver","text":"public  function F4(x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in), dimension(:) :: x Return Value complex(kind=rk), dimension(:), allocatable Source Code function F4 ( x ) result ( F_val ) complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F4","tags":"","url":"proc/f4~2.html"},{"title":"F2 – ForSolver","text":"public  function F2(x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x Return Value complex(kind=rk) Source Code function F2 ( x ) result ( F_val ) complex ( rk ), intent ( in ) :: x complex ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F2","tags":"","url":"proc/f2~2.html"},{"title":"F1 – ForSolver","text":"public  function F1(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) Source Code function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1","tags":"","url":"proc/f1~3.html"},{"title":"gels – ForSolver","text":"public interface gels Called by interface~~gels~~CalledByGraph interface~gels gels proc~gels_rel gels_rel proc~gels_rel->interface~gels proc~solver_lin solver_lin proc~solver_lin->proc~gels_rel interface~solve solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve program~test_solver1 test_solver1 program~test_solver1->interface~solve program~test_solver15 test_solver15 program~test_solver15->interface~solve program~test_solver16 test_solver16 program~test_solver16->interface~solve program~test_solver17 test_solver17 program~test_solver17->interface~solve program~test_solver2 test_solver2 program~test_solver2->interface~solve proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine sgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo","tags":"","url":"interface/gels.html"},{"title":"gesv – ForSolver","text":"public interface gesv Called by interface~~gesv~~CalledByGraph interface~gesv gesv proc~gesv_rel gesv_rel proc~gesv_rel->interface~gesv proc~solver_lin solver_lin proc~solver_lin->proc~gesv_rel interface~solve solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve program~test_solver1 test_solver1 program~test_solver1->interface~solve program~test_solver15 test_solver15 program~test_solver15->interface~solve program~test_solver16 test_solver16 program~test_solver16->interface~solve program~test_solver17 test_solver17 program~test_solver17->interface~solve program~test_solver2 test_solver2 program~test_solver2->interface~solve proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine sgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo","tags":"","url":"interface/gesv.html"},{"title":"F3 – ForSolver","text":"public  function F3(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable Source Code function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3","tags":"","url":"proc/f3.html"},{"title":"F1 – ForSolver","text":"public  function F1(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) Source Code function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1","tags":"","url":"proc/f1~4.html"},{"title":"F3 – ForSolver","text":"public  function F3(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable Source Code function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3","tags":"","url":"proc/f3~2.html"},{"title":"solver_lin – ForSolver","text":"private pure function solver_lin(A, b, method) result(x) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2))) Calls proc~~solver_lin~~CallsGraph proc~solver_lin solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~solver_lin~~CalledByGraph proc~solver_lin solver_lin interface~solve solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve program~test_solver1 test_solver1 program~test_solver1->interface~solve program~test_solver15 test_solver15 program~test_solver15->interface~solve program~test_solver16 test_solver16 program~test_solver16->interface~solve program~test_solver17 test_solver17 program~test_solver17->interface~solve program~test_solver2 test_solver2 program~test_solver2->interface~solve proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function solver_lin ( A , b , method ) result ( x ) ! inputs real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b character ( * ), optional , intent ( in ) :: method ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))) :: x ! solution matrix x ! local variables integer :: info ! result info ! call solver if ( present ( method )) then select case ( method ) case ( 'gesv' ) call gesv_rel ( A , b , x , info ) case ( 'gels' ) call gels_rel ( A , b , x , info ) end select else if ( size ( A , 1 ) == size ( A , 2 )) then call gesv_rel ( A , b , x , info ) else call gels_rel ( A , b , x , info ) end if end if end function solver_lin","tags":"","url":"proc/solver_lin.html"},{"title":"deallocate_solver – ForSolver","text":"private pure elemental subroutine deallocate_solver(this) Arguments Type Intent Optional Attributes Name type( nlsolver ), intent(inout) :: this Source Code elemental pure subroutine deallocate_solver ( this ) type ( nlsolver ), intent ( inout ) :: this if ( allocated ( this % nl_method )) deallocate ( this % nl_method ) if ( allocated ( this % fdm_method )) deallocate ( this % fdm_method ) end subroutine deallocate_solver","tags":"","url":"proc/deallocate_solver.html"},{"title":"gels_rel – ForSolver","text":"private pure subroutine gels_rel(A, b, x, info) Uses external_interfaces_solver proc~~gels_rel~~UsesGraph proc~gels_rel gels_rel module~external_interfaces_solver external_interfaces_solver proc~gels_rel->module~external_interfaces_solver module~forsolver_kinds forsolver_kinds module~external_interfaces_solver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. solves an overdetermined or underdetermined linear system using gels. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info Calls proc~~gels_rel~~CallsGraph proc~gels_rel gels_rel interface~gels gels proc~gels_rel->interface~gels Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gels_rel~~CalledByGraph proc~gels_rel gels_rel proc~solver_lin solver_lin proc~solver_lin->proc~gels_rel interface~solve solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve program~test_solver1 test_solver1 program~test_solver1->interface~solve program~test_solver15 test_solver15 program~test_solver15->interface~solve program~test_solver16 test_solver16 program~test_solver16->interface~solve program~test_solver17 test_solver17 program~test_solver17->interface~solve program~test_solver2 test_solver2 program~test_solver2->interface~solve proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine gels_rel ( A , b , x , info ) use external_interfaces_solver , only : gels ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables character ( 1 ) :: trans integer :: m , n , lda , ldb , lwork , nrhs real ( rk ), allocatable :: work (:) real ( rk ) :: work1 ( 1 ) real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! trans = 'n' ! get dimensions nrhs = 1 ! size(b, 2) m = size ( A , 1 ) n = size ( A , 2 ) lda = max ( 1 , m ) ldb = max ( 1 , max ( m , n )) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! calculate the optimal size of the work array call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work1 , - 1 , info ) ! allocate work array lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) ! call gels subroutine call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work , lwork , info ) ! copy the solution matrix if ( info == 0 ) then if ( trans == 'n' ) x = b_copy ( 1 : n , 1 ) ! nrhs = 1 if ( trans == 't' ) x = b_copy ( 1 : m , 1 ) ! nrhs = 1 else error stop 'gels failed' end if ! deallocate workspace deallocate ( work ) end subroutine gels_rel","tags":"","url":"proc/gels_rel.html"},{"title":"gesv_rel – ForSolver","text":"private pure subroutine gesv_rel(A, b, x, info) Uses external_interfaces_solver proc~~gesv_rel~~UsesGraph proc~gesv_rel gesv_rel module~external_interfaces_solver external_interfaces_solver proc~gesv_rel->module~external_interfaces_solver module~forsolver_kinds forsolver_kinds module~external_interfaces_solver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info Calls proc~~gesv_rel~~CallsGraph proc~gesv_rel gesv_rel interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gesv_rel~~CalledByGraph proc~gesv_rel gesv_rel proc~solver_lin solver_lin proc~solver_lin->proc~gesv_rel interface~solve solve interface~solve->proc~solver_lin proc~modified_newton_method_t1 modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve program~test_solver1 test_solver1 program~test_solver1->interface~solve program~test_solver15 test_solver15 program~test_solver15->interface~solve program~test_solver16 test_solver16 program~test_solver16->interface~solve program~test_solver17 test_solver17 program~test_solver17->interface~solve program~test_solver2 test_solver2 program~test_solver2->interface~solve proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine gesv_rel ( A , b , x , info ) use external_interfaces_solver , only : gesv ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables integer :: n , lda , ldb , nrhs integer , dimension ( size ( A , 2 )) :: ipiv real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! get dimensions nrhs = 1 ! size(b, 2) n = size ( A , 2 ) lda = max ( 1 , n ) ldb = max ( 1 , n ) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! call gels subroutine call gesv ( n , nrhs , a_copy , lda , ipiv , b_copy , ldb , info ) ! copy the solution matrix if ( info == 0 ) then x = b_copy ( 1 : ldb , 1 ) ! nrhs = 1 else error stop 'gesv failed' end if end subroutine gesv_rel","tags":"","url":"proc/gesv_rel.html"},{"title":"modified_newton_method_T0 – ForSolver","text":"private impure subroutine modified_newton_method_T0(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun6) :: F procedure(dFun6) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Called by proc~~modified_newton_method_t0~~CalledByGraph proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0 nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 none~solve nlsolver%solve none~solve->proc~newton_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun6 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun6 impure function dFun6 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun6 end interface procedure ( Fun6 ) :: F procedure ( dFun6 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T0","tags":"","url":"proc/modified_newton_method_t0.html"},{"title":"modified_newton_method_T1 – ForSolver","text":"private impure subroutine modified_newton_method_T1(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun11) :: F procedure(dFun11) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~modified_newton_method_t1~~CallsGraph proc~modified_newton_method_t1 modified_newton_method_T1 interface~solve solve proc~modified_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_newton_method_t1~~CalledByGraph proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun11 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun11 impure function dFun11 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun11 end interface procedure ( Fun11 ) :: F procedure ( dFun11 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T1","tags":"","url":"proc/modified_newton_method_t1.html"},{"title":"modified_quasi_cs_newton_method_T0 – ForSolver","text":"private impure subroutine modified_quasi_cs_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun15) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol Calls proc~~modified_quasi_cs_newton_method_t0~~CallsGraph proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_cs_newton_method_t0~~CalledByGraph proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun15 ( x ) result ( res ) import rk implicit none complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun15 end interface procedure ( Fun15 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T0","tags":"","url":"proc/modified_quasi_cs_newton_method_t0.html"},{"title":"modified_quasi_cs_newton_method_T1 – ForSolver","text":"private impure subroutine modified_quasi_cs_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun17) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~modified_quasi_cs_newton_method_t1~~CallsGraph proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 derivative derivative proc~modified_quasi_cs_newton_method_t1->derivative interface~solve solve proc~modified_quasi_cs_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_cs_newton_method_t1~~CalledByGraph proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun17 ( x ) result ( res ) import rk implicit none complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun17 end interface procedure ( Fun17 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T1","tags":"","url":"proc/modified_quasi_cs_newton_method_t1.html"},{"title":"modified_quasi_fd_newton_method_T0 – ForSolver","text":"private impure subroutine modified_quasi_fd_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun8) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Calls proc~~modified_quasi_fd_newton_method_t0~~CallsGraph proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 derivative derivative proc~modified_quasi_fd_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_fd_newton_method_t0~~CalledByGraph proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0 nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 none~solve nlsolver%solve none~solve->proc~newton_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun8 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun8 end interface procedure ( Fun8 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T0","tags":"","url":"proc/modified_quasi_fd_newton_method_t0.html"},{"title":"modified_quasi_fd_newton_method_T1 – ForSolver","text":"private impure subroutine modified_quasi_fd_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun13) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~modified_quasi_fd_newton_method_t1~~CallsGraph proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 derivative derivative proc~modified_quasi_fd_newton_method_t1->derivative interface~solve solve proc~modified_quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~modified_quasi_fd_newton_method_t1~~CalledByGraph proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun13 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun13 end interface procedure ( Fun13 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T1","tags":"","url":"proc/modified_quasi_fd_newton_method_t1.html"},{"title":"newton_complex_step_rel_T0 – ForSolver","text":"private impure subroutine newton_complex_step_rel_T0(this, F, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol Calls proc~~newton_complex_step_rel_t0~~CallsGraph proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newton_complex_step_rel_t0~~CalledByGraph proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_complex_step_rel_T0 ( this , F , x0 , x_sol ) interface impure function Fun3 ( x ) result ( res ) import rk implicit none complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun3 end interface procedure ( Fun3 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , real ( x0 , kind = rk ), this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)        dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_complex_step_rel_T0","tags":"","url":"proc/newton_complex_step_rel_t0.html"},{"title":"newton_complex_step_rel_T1 – ForSolver","text":"private impure subroutine newton_complex_step_rel_T1(this, F, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~newton_complex_step_rel_t1~~CallsGraph proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 derivative derivative proc~modified_quasi_cs_newton_method_t1->derivative interface~solve solve proc~modified_quasi_cs_newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newton_complex_step_rel_t1~~CalledByGraph proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_complex_step_rel_T1 ( this , F , x0 , x_sol ) interface impure function Fun4 ( x ) result ( res ) import rk implicit none complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun4 end interface procedure ( Fun4 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, f12.8, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , real ( x_sol ( i ), kind = rk ) end do ! print '(a, g0)', 'x_sol = ', x_sol end if end subroutine newton_complex_step_rel_T1","tags":"","url":"proc/newton_complex_step_rel_t1.html"},{"title":"newton_method_T0 – ForSolver","text":"private impure subroutine newton_method_T0(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun5) :: F procedure(dFun5) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Called by proc~~newton_method_t0~~CalledByGraph proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0 nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~newton_method_t0 none~solve nlsolver%solve none~solve->proc~newton_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun5 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun5 impure function dFun5 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun5 end interface procedure ( Fun5 ) :: F procedure ( dFun5 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T0","tags":"","url":"proc/newton_method_t0.html"},{"title":"newton_method_T1 – ForSolver","text":"private impure subroutine newton_method_T1(this, F, dFdx, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun9) :: F procedure(dFun10) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~newton_method_t1~~CallsGraph proc~newton_method_t1 newton_method_T1 interface~solve solve proc~newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newton_method_t1~~CalledByGraph proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun9 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun9 impure function dFun10 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun10 end interface procedure ( Fun9 ) :: F procedure ( dFun10 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T1","tags":"","url":"proc/newton_method_t1.html"},{"title":"newton_rel_T0 – ForSolver","text":"private impure subroutine newton_rel_T0(this, F, dFdx, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Calls proc~~newton_rel_t0~~CallsGraph proc~newton_rel_t0 nlsolver%newton_rel_T0 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 derivative derivative proc~modified_quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newton_rel_t0~~CalledByGraph proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve nlsolver%solve none~solve->proc~newton_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_rel_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun1 ( x ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: Fun1 end function Fun1 impure function dFun1 ( x ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: dFun1 end function dFun1 end interface procedure ( Fun1 ) :: F procedure ( dFun1 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , x0 , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)         dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) !  case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) !  case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_rel_T0","tags":"","url":"proc/newton_rel_t0.html"},{"title":"newton_rel_T1 – ForSolver","text":"private impure subroutine newton_rel_T1(this, F, dFdx, x0, x_sol) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~newton_rel_t1~~CallsGraph proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newton_rel_t1~~CalledByGraph proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve nlsolver%solve none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine newton_rel_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun2 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun2 impure function dFun2 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun2 end interface procedure ( Fun2 ) :: F procedure ( dFun2 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) ! case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) ! case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , x_sol ( i ) end do end if end subroutine newton_rel_T1","tags":"","url":"proc/newton_rel_t1.html"},{"title":"quasi_cs_newton_method_T0 – ForSolver","text":"private impure subroutine quasi_cs_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun14) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol Calls proc~~quasi_cs_newton_method_t0~~CallsGraph proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 derivative derivative proc~quasi_cs_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_cs_newton_method_t0~~CalledByGraph proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun14 ( x ) result ( res ) import rk implicit none complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun14 end interface procedure ( Fun14 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T0","tags":"","url":"proc/quasi_cs_newton_method_t0.html"},{"title":"quasi_cs_newton_method_T1 – ForSolver","text":"private impure subroutine quasi_cs_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun16) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~quasi_cs_newton_method_t1~~CallsGraph proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 derivative derivative proc~quasi_cs_newton_method_t1->derivative interface~solve solve proc~quasi_cs_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_cs_newton_method_t1~~CalledByGraph proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun16 ( x ) result ( res ) import rk implicit none complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun16 end interface procedure ( Fun16 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T1","tags":"","url":"proc/quasi_cs_newton_method_t1.html"},{"title":"quasi_fd_newton_method_T0 – ForSolver","text":"private impure subroutine quasi_fd_newton_method_T0(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun7) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol Calls proc~~quasi_fd_newton_method_t0~~CallsGraph proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 derivative derivative proc~quasi_fd_newton_method_t0->derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_fd_newton_method_t0~~CalledByGraph proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0 nlsolver%newton_rel_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 none~solve nlsolver%solve none~solve->proc~newton_rel_t0 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun7 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun7 end interface procedure ( Fun7 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T0","tags":"","url":"proc/quasi_fd_newton_method_t0.html"},{"title":"quasi_fd_newton_method_T1 – ForSolver","text":"private impure subroutine quasi_fd_newton_method_T1(this, F, x0, x_sol) Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun12) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol Calls proc~~quasi_fd_newton_method_t1~~CallsGraph proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 derivative derivative proc~quasi_fd_newton_method_t1->derivative interface~solve solve proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quasi_fd_newton_method_t1~~CalledByGraph proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun12 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun12 end interface procedure ( Fun12 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T1","tags":"","url":"proc/quasi_fd_newton_method_t1.html"},{"title":"set_options – ForSolver","text":"private impure subroutine set_options(this, nl_method, lin_method, maxit, TolFun, alpha0, c1, c2, nmp, fdm_method, fdm_tol, cs_tol, stepsize, verbosity) Type Bound nlsolver Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this character(len=*), intent(in), optional :: nl_method character(len=*), intent(in), optional :: lin_method integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: TolFun real(kind=rk), intent(in), optional :: alpha0 real(kind=rk), intent(in), optional :: c1 real(kind=rk), intent(in), optional :: c2 integer, intent(in), optional :: nmp character(len=*), intent(in), optional :: fdm_method real(kind=rk), intent(in), optional :: fdm_tol real(kind=rk), intent(in), optional :: cs_tol character(len=*), intent(in), optional :: stepsize integer, intent(in), optional :: verbosity Called by proc~~set_options~~CalledByGraph proc~set_options nlsolver%set_options program~test_solver10 test_solver10 program~test_solver10->proc~set_options program~test_solver11 test_solver11 program~test_solver11->proc~set_options program~test_solver12 test_solver12 program~test_solver12->proc~set_options program~test_solver13 test_solver13 program~test_solver13->proc~set_options program~test_solver14 test_solver14 program~test_solver14->proc~set_options program~test_solver3 test_solver3 program~test_solver3->proc~set_options program~test_solver4 test_solver4 program~test_solver4->proc~set_options program~test_solver5 test_solver5 program~test_solver5->proc~set_options program~test_solver6 test_solver6 program~test_solver6->proc~set_options program~test_solver7 test_solver7 program~test_solver7->proc~set_options program~test_solver8 test_solver8 program~test_solver8->proc~set_options program~test_solver9 test_solver9 program~test_solver9->proc~set_options Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine set_options ( this ,& nl_method , lin_method , maxit , TolFun , alpha0 , c1 , c2 , nmp , fdm_method , fdm_tol , cs_tol , stepsize , verbosity ) class ( nlsolver ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: nl_method character ( * ), intent ( in ), optional :: lin_method character ( * ), intent ( in ), optional :: stepsize character ( * ), intent ( in ), optional :: fdm_method real ( rk ), intent ( in ), optional :: TolFun real ( rk ), intent ( in ), optional :: fdm_tol real ( rk ), intent ( in ), optional :: cs_tol integer , intent ( in ), optional :: maxit real ( rk ), intent ( in ), optional :: alpha0 real ( rk ), intent ( in ), optional :: c1 real ( rk ), intent ( in ), optional :: c2 integer , intent ( in ), optional :: nmp integer , intent ( in ), optional :: verbosity if ( present ( nl_method )) then this % nl_method = nl_method else this % nl_method = 'newton' end if if ( present ( lin_method )) then this % lin_method = lin_method else this % lin_method = 'gels' end if if ( present ( fdm_method )) then this % fdm_method = fdm_method else this % fdm_method = 'forward' end if if ( present ( maxit )) then this % maxit = maxit else this % maxit = 100 end if if ( present ( TolFun )) then this % TolFun = TolFun else this % TolFun = 1e-4_rk end if if ( present ( fdm_tol )) then this % fdm_tol = fdm_tol else this % fdm_tol = 1e-4_rk end if if ( present ( cs_tol )) then this % cs_tol = cs_tol else this % cs_tol = 1e-100_rk end if if ( present ( nmp )) then this % nmp = nmp else this % nmp = 2 end if if ( present ( verbosity )) then this % verbosity = verbosity else this % verbosity = 1 end if ! if (present(stepsize))   this%stepsize   = stepsize ! if (present(alpha0))     this%alpha0     = alpha0 ! if (present(c1))         this%c1         = c1 ! if (present(c2))         this%c2         = c2 end subroutine set_options","tags":"","url":"proc/set_options.html"},{"title":"solve – ForSolver","text":"public interface solve Calls interface~~solve~~CallsGraph interface~solve solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~solve~~CalledByGraph interface~solve solve proc~modified_newton_method_t1 modified_newton_method_T1 proc~modified_newton_method_t1->interface~solve proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1 newton_method_T1 proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~quasi_fd_newton_method_t1->interface~solve program~test_solver1 test_solver1 program~test_solver1->interface~solve program~test_solver15 test_solver15 program~test_solver15->interface~solve program~test_solver16 test_solver16 program~test_solver16->interface~solve program~test_solver17 test_solver17 program~test_solver17->interface~solve program~test_solver2 test_solver2 program~test_solver2->interface~solve proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~newton_rel_t1 nlsolver%newton_rel_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_rel_t1->proc~newton_method_t1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 none~solve nlsolver%solve none~solve->proc~newton_complex_step_rel_t1 none~solve->proc~newton_rel_t1 program~test_solver10 test_solver10 program~test_solver10->none~solve program~test_solver11 test_solver11 program~test_solver11->none~solve program~test_solver12 test_solver12 program~test_solver12->none~solve program~test_solver13 test_solver13 program~test_solver13->none~solve program~test_solver14 test_solver14 program~test_solver14->none~solve program~test_solver3 test_solver3 program~test_solver3->none~solve program~test_solver4 test_solver4 program~test_solver4->none~solve program~test_solver5 test_solver5 program~test_solver5->none~solve program~test_solver6 test_solver6 program~test_solver6->none~solve program~test_solver7 test_solver7 program~test_solver7->none~solve program~test_solver8 test_solver8 program~test_solver8->none~solve program~test_solver9 test_solver9 program~test_solver9->none~solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function solver_lin (A, b, method) result(x) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2)))","tags":"","url":"interface/solve.html"},{"title":"F3 – ForSolver","text":"public  function F3(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable Source Code function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3","tags":"","url":"proc/f3~3.html"},{"title":"dF3dx – ForSolver","text":"public  function dF3dx(x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:,:), allocatable Source Code function dF3dx ( x ) result ( dFdx_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: dFdx_val allocate ( dFdx_val ( 2 , 2 )) dFdx_val ( 1 , 1 ) = 120 0.0_rk * x ( 1 ) ** 2 - 40 0.0_rk * x ( 2 ) + 2.0_rk dFdx_val ( 1 , 2 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 1 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 2 ) = 20 0.0_rk end function dF3dx","tags":"","url":"proc/df3dx.html"},{"title":"F3 – ForSolver","text":"public  function F3(x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable Source Code function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3","tags":"","url":"proc/f3~4.html"},{"title":"dF3dx – ForSolver","text":"public  function dF3dx(x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:,:), allocatable Source Code function dF3dx ( x ) result ( dFdx_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: dFdx_val allocate ( dFdx_val ( 2 , 2 )) dFdx_val ( 1 , 1 ) = 120 0.0_rk * x ( 1 ) ** 2 - 40 0.0_rk * x ( 2 ) + 2.0_rk dFdx_val ( 1 , 2 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 1 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 2 ) = 20 0.0_rk end function dF3dx","tags":"","url":"proc/df3dx~2.html"},{"title":"my_function14 – ForSolver","text":"Uses forsolver_kinds module~~my_function14~~UsesGraph module~my_function14 my_function14 module~forsolver_kinds forsolver_kinds module~my_function14->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function14~~UsedByGraph module~my_function14 my_function14 program~test_solver14 test_solver14 program~test_solver14->module~my_function14 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F4 (x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in), dimension(:) :: x Return Value complex(kind=rk), dimension(:), allocatable","tags":"","url":"module/my_function14.html"},{"title":"my_function7 – ForSolver","text":"Uses forsolver_kinds module~~my_function7~~UsesGraph module~my_function7 my_function7 module~forsolver_kinds forsolver_kinds module~my_function7->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function7~~UsedByGraph module~my_function7 my_function7 program~test_solver7 test_solver7 program~test_solver7->module~my_function7 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F2 (x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x Return Value complex(kind=rk)","tags":"","url":"module/my_function7.html"},{"title":"my_function4 – ForSolver","text":"Uses forsolver_kinds module~~my_function4~~UsesGraph module~my_function4 my_function4 module~forsolver_kinds forsolver_kinds module~my_function4->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function4~~UsedByGraph module~my_function4 my_function4 program~test_solver4 test_solver4 program~test_solver4->module~my_function4 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F1 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) public  function dF1dx (x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk)","tags":"","url":"module/my_function4.html"},{"title":"forsolver_kinds – ForSolver","text":"Used by module~~forsolver_kinds~~UsedByGraph module~forsolver_kinds forsolver_kinds module~external_interfaces_solver external_interfaces_solver module~external_interfaces_solver->module~forsolver_kinds module~forsolver forsolver module~forsolver->module~forsolver_kinds module~my_function10 my_function10 module~my_function10->module~forsolver_kinds module~my_function11 my_function11 module~my_function11->module~forsolver_kinds module~my_function12 my_function12 module~my_function12->module~forsolver_kinds module~my_function13 my_function13 module~my_function13->module~forsolver_kinds module~my_function14 my_function14 module~my_function14->module~forsolver_kinds module~my_function3 my_function3 module~my_function3->module~forsolver_kinds module~my_function4 my_function4 module~my_function4->module~forsolver_kinds module~my_function5 my_function5 module~my_function5->module~forsolver_kinds module~my_function6 my_function6 module~my_function6->module~forsolver_kinds module~my_function7 my_function7 module~my_function7->module~forsolver_kinds module~my_function8 my_function8 module~my_function8->module~forsolver_kinds module~my_function9 my_function9 module~my_function9->module~forsolver_kinds program~test_solver10 test_solver10 program~test_solver10->module~forsolver_kinds program~test_solver10->module~forsolver program~test_solver10->module~my_function10 program~test_solver11 test_solver11 program~test_solver11->module~forsolver_kinds program~test_solver11->module~forsolver program~test_solver11->module~my_function11 program~test_solver12 test_solver12 program~test_solver12->module~forsolver_kinds program~test_solver12->module~forsolver program~test_solver12->module~my_function12 program~test_solver13 test_solver13 program~test_solver13->module~forsolver_kinds program~test_solver13->module~forsolver program~test_solver13->module~my_function13 program~test_solver14 test_solver14 program~test_solver14->module~forsolver_kinds program~test_solver14->module~forsolver program~test_solver14->module~my_function14 program~test_solver3 test_solver3 program~test_solver3->module~forsolver_kinds program~test_solver3->module~forsolver program~test_solver3->module~my_function3 program~test_solver4 test_solver4 program~test_solver4->module~forsolver_kinds program~test_solver4->module~forsolver program~test_solver4->module~my_function4 program~test_solver5 test_solver5 program~test_solver5->module~forsolver_kinds program~test_solver5->module~forsolver program~test_solver5->module~my_function5 program~test_solver6 test_solver6 program~test_solver6->module~forsolver_kinds program~test_solver6->module~forsolver program~test_solver6->module~my_function6 program~test_solver7 test_solver7 program~test_solver7->module~forsolver_kinds program~test_solver7->module~forsolver program~test_solver7->module~my_function7 program~test_solver8 test_solver8 program~test_solver8->module~forsolver_kinds program~test_solver8->module~forsolver program~test_solver8->module~my_function8 program~test_solver9 test_solver9 program~test_solver9->module~forsolver_kinds program~test_solver9->module~forsolver program~test_solver9->module~my_function9 proc~gels_rel gels_rel proc~gels_rel->module~external_interfaces_solver proc~gesv_rel gesv_rel proc~gesv_rel->module~external_interfaces_solver program~test_solver1 test_solver1 program~test_solver1->module~forsolver program~test_solver15 test_solver15 program~test_solver15->module~forsolver program~test_solver16 test_solver16 program~test_solver16->module~forsolver program~test_solver17 test_solver17 program~test_solver17->module~forsolver program~test_solver2 test_solver2 program~test_solver2->module~forsolver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rk = selected_real_kind(15)","tags":"","url":"module/forsolver_kinds.html"},{"title":"my_function3 – ForSolver","text":"Uses forsolver_kinds module~~my_function3~~UsesGraph module~my_function3 my_function3 module~forsolver_kinds forsolver_kinds module~my_function3->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function3~~UsedByGraph module~my_function3 my_function3 program~test_solver3 test_solver3 program~test_solver3->module~my_function3 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F1 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk) public  function dF1dx (x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk)","tags":"","url":"module/my_function3.html"},{"title":"my_function13 – ForSolver","text":"Uses forsolver_kinds module~~my_function13~~UsesGraph module~my_function13 my_function13 module~forsolver_kinds forsolver_kinds module~my_function13->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function13~~UsedByGraph module~my_function13 my_function13 program~test_solver13 test_solver13 program~test_solver13->module~my_function13 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F4 (x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in), dimension(:) :: x Return Value complex(kind=rk), dimension(:), allocatable","tags":"","url":"module/my_function13.html"},{"title":"my_function8 – ForSolver","text":"Uses forsolver_kinds module~~my_function8~~UsesGraph module~my_function8 my_function8 module~forsolver_kinds forsolver_kinds module~my_function8->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function8~~UsedByGraph module~my_function8 my_function8 program~test_solver8 test_solver8 program~test_solver8->module~my_function8 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F2 (x) result(F_val) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x Return Value complex(kind=rk)","tags":"","url":"module/my_function8.html"},{"title":"my_function6 – ForSolver","text":"Uses forsolver_kinds module~~my_function6~~UsesGraph module~my_function6 my_function6 module~forsolver_kinds forsolver_kinds module~my_function6->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function6~~UsedByGraph module~my_function6 my_function6 program~test_solver6 test_solver6 program~test_solver6->module~my_function6 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F1 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk)","tags":"","url":"module/my_function6.html"},{"title":"external_interfaces_solver – ForSolver","text":"Uses forsolver_kinds module~~external_interfaces_solver~~UsesGraph module~external_interfaces_solver external_interfaces_solver module~forsolver_kinds forsolver_kinds module~external_interfaces_solver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~external_interfaces_solver~~UsedByGraph module~external_interfaces_solver external_interfaces_solver proc~gels_rel gels_rel proc~gels_rel->module~external_interfaces_solver proc~gesv_rel gesv_rel proc~gesv_rel->module~external_interfaces_solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface gels public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine dgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public pure subroutine sgels(ftrans, fm, fn, fnrhs, fa, flda, fb, fldb, fwork, flwork, finfo) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ftrans integer, intent(in) :: fm integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,*) integer, intent(in) :: flda real(kind=rk), intent(inout) :: fb (fldb,*) integer, intent(in) :: fldb real(kind=rk), intent(in) :: fwork (*) integer, intent(in) :: flwork integer, intent(out) :: finfo public        interface gesv public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine dgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo public pure subroutine sgesv(fn, fnrhs, fa, flda, fipiv, fb, fldb, finfo) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn integer, intent(in) :: fnrhs real(kind=rk), intent(inout) :: fa (flda,fn) integer, intent(in) :: flda integer, intent(out) :: fipiv (fn) real(kind=rk), intent(inout) :: fb (fldb,fnrhs) integer, intent(in) :: fldb integer, intent(out) :: finfo","tags":"","url":"module/external_interfaces_solver.html"},{"title":"my_function12 – ForSolver","text":"Uses forsolver_kinds module~~my_function12~~UsesGraph module~my_function12 my_function12 module~forsolver_kinds forsolver_kinds module~my_function12->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function12~~UsedByGraph module~my_function12 my_function12 program~test_solver12 test_solver12 program~test_solver12->module~my_function12 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F3 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable","tags":"","url":"module/my_function12.html"},{"title":"my_function5 – ForSolver","text":"Uses forsolver_kinds module~~my_function5~~UsesGraph module~my_function5 my_function5 module~forsolver_kinds forsolver_kinds module~my_function5->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function5~~UsedByGraph module~my_function5 my_function5 program~test_solver5 test_solver5 program~test_solver5->module~my_function5 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F1 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x Return Value real(kind=rk)","tags":"","url":"module/my_function5.html"},{"title":"my_function11 – ForSolver","text":"Uses forsolver_kinds module~~my_function11~~UsesGraph module~my_function11 my_function11 module~forsolver_kinds forsolver_kinds module~my_function11->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function11~~UsedByGraph module~my_function11 my_function11 program~test_solver11 test_solver11 program~test_solver11->module~my_function11 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F3 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable","tags":"","url":"module/my_function11.html"},{"title":"forsolver – ForSolver","text":"Uses forsolver_kinds fordiff module~~forsolver~~UsesGraph module~forsolver forsolver fordiff fordiff module~forsolver->fordiff module~forsolver_kinds forsolver_kinds module~forsolver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forsolver~~UsedByGraph module~forsolver forsolver program~test_solver1 test_solver1 program~test_solver1->module~forsolver program~test_solver10 test_solver10 program~test_solver10->module~forsolver program~test_solver11 test_solver11 program~test_solver11->module~forsolver program~test_solver12 test_solver12 program~test_solver12->module~forsolver program~test_solver13 test_solver13 program~test_solver13->module~forsolver program~test_solver14 test_solver14 program~test_solver14->module~forsolver program~test_solver15 test_solver15 program~test_solver15->module~forsolver program~test_solver16 test_solver16 program~test_solver16->module~forsolver program~test_solver17 test_solver17 program~test_solver17->module~forsolver program~test_solver2 test_solver2 program~test_solver2->module~forsolver program~test_solver3 test_solver3 program~test_solver3->module~forsolver program~test_solver4 test_solver4 program~test_solver4->module~forsolver program~test_solver5 test_solver5 program~test_solver5->module~forsolver program~test_solver6 test_solver6 program~test_solver6->module~forsolver program~test_solver7 test_solver7 program~test_solver7->module~forsolver program~test_solver8 test_solver8 program~test_solver8->module~forsolver program~test_solver9 test_solver9 program~test_solver9->module~forsolver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface solve private pure function solver_lin (A, b, method) result(x) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2))) Derived Types type, public :: nlsolver Components Type Visibility Attributes Name Initial real(kind=rk), public :: TolFun real(kind=rk), public :: cs_tol character(len=:), public, allocatable :: fdm_method real(kind=rk), public :: fdm_tol character(len=:), public, allocatable :: lin_method integer, public :: maxit character(len=:), public, allocatable :: nl_method integer, public :: nmp integer, public :: verbosity Finalizations Procedures final :: deallocate_solver Type-Bound Procedures procedure, public :: newton_complex_step_rel_T0 procedure, public :: newton_complex_step_rel_T1 procedure, public :: newton_rel_T0 procedure, public :: newton_rel_T1 procedure, public :: set_options generic, public :: solve => newton_rel_T0 , newton_rel_T1 , newton_complex_step_rel_T0 , newton_complex_step_rel_T1 Functions private pure function solver_lin (A, b, method) result(x) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b character(len=*), intent(in), optional :: method Return Value real(kind=rk), dimension(max(1, size(A, 2))) Subroutines private pure elemental subroutine deallocate_solver (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name type( nlsolver ), intent(inout) :: this private pure subroutine gels_rel (A, b, x, info) Author Seyed Ali Ghasemi License BSD 3-Clause solves an overdetermined or underdetermined linear system using gels. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info private pure subroutine gesv_rel (A, b, x, info) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: b real(kind=rk), intent(out), dimension(max(1, size(A, 2))) :: x integer, intent(out) :: info private impure subroutine modified_newton_method_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun6) :: F procedure(dFun6) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine modified_newton_method_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun11) :: F procedure(dFun11) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine modified_quasi_cs_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun15) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine modified_quasi_cs_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun17) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine modified_quasi_fd_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun8) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine modified_quasi_fd_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun13) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine newton_complex_step_rel_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun3) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine newton_complex_step_rel_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun4) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine newton_method_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun5) :: F procedure(dFun5) :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine newton_method_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun9) :: F procedure(dFun10) :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine newton_rel_T0 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun1) :: F procedure(dFun1), optional :: dFdx real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine newton_rel_T1 (this, F, dFdx, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun2) :: F procedure(dFun2), optional :: dFdx real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine quasi_cs_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun14) :: F complex(kind=rk), intent(in) :: x0 complex(kind=rk), intent(out) :: x_sol private impure subroutine quasi_cs_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun16) :: F complex(kind=rk), intent(in), dimension(:) :: x0 complex(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine quasi_fd_newton_method_T0 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun7) :: F real(kind=rk), intent(in) :: x0 real(kind=rk), intent(out) :: x_sol private impure subroutine quasi_fd_newton_method_T1 (this, F, x0, x_sol) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this procedure(Fun12) :: F real(kind=rk), intent(in), dimension(:) :: x0 real(kind=rk), intent(out), dimension(size(x0)) :: x_sol private impure subroutine set_options (this, nl_method, lin_method, maxit, TolFun, alpha0, c1, c2, nmp, fdm_method, fdm_tol, cs_tol, stepsize, verbosity) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( nlsolver ), intent(inout) :: this character(len=*), intent(in), optional :: nl_method character(len=*), intent(in), optional :: lin_method integer, intent(in), optional :: maxit real(kind=rk), intent(in), optional :: TolFun real(kind=rk), intent(in), optional :: alpha0 real(kind=rk), intent(in), optional :: c1 real(kind=rk), intent(in), optional :: c2 integer, intent(in), optional :: nmp character(len=*), intent(in), optional :: fdm_method real(kind=rk), intent(in), optional :: fdm_tol real(kind=rk), intent(in), optional :: cs_tol character(len=*), intent(in), optional :: stepsize integer, intent(in), optional :: verbosity","tags":"","url":"module/forsolver.html"},{"title":"my_function10 – ForSolver","text":"Uses forsolver_kinds module~~my_function10~~UsesGraph module~my_function10 my_function10 module~forsolver_kinds forsolver_kinds module~my_function10->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function10~~UsedByGraph module~my_function10 my_function10 program~test_solver10 test_solver10 program~test_solver10->module~my_function10 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F3 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable public  function dF3dx (x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:,:), allocatable","tags":"","url":"module/my_function10.html"},{"title":"my_function9 – ForSolver","text":"Uses forsolver_kinds module~~my_function9~~UsesGraph module~my_function9 my_function9 module~forsolver_kinds forsolver_kinds module~my_function9->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_function9~~UsedByGraph module~my_function9 my_function9 program~test_solver9 test_solver9 program~test_solver9->module~my_function9 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function F3 (x) result(F_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:), allocatable public  function dF3dx (x) result(dFdx_val) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Return Value real(kind=rk), dimension(:,:), allocatable","tags":"","url":"module/my_function9.html"},{"title":"test_solver14 – ForSolver","text":"Uses forsolver_kinds forunittest forsolver my_function14 program~~test_solver14~~UsesGraph program~test_solver14 test_solver14 forunittest forunittest program~test_solver14->forunittest module~forsolver forsolver program~test_solver14->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver14->module~forsolver_kinds module~my_function14 my_function14 program~test_solver14->module~my_function14 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function14->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver14~~CallsGraph program~test_solver14 test_solver14 check check program~test_solver14->check none~solve nlsolver%solve program~test_solver14->none~solve proc~set_options nlsolver%set_options program~test_solver14->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(2) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut complex(kind=rk), dimension(2) :: x Source Code program test_solver14 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function14 , only : F4 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ), dimension ( 2 ) :: x real ( rk ), dimension ( 2 ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs-modified' ,& cs_tol = tiny ( 0.0_rk ),& nmp = 1 ,& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F4 , x0 = [( 0.95_rk , 0.0_rk ) ,( 0.95_rk , 0.0_rk )], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( real ( x , rk ), expected_x , 1.0e-1_rk , 'test_solver14' ) ! call ut%check(x%re, expected_x, 1.0e-1_rk, 'test_solver14' ) end program test_solver14","tags":"","url":"program/test_solver14.html"},{"title":"test_solver7 – ForSolver","text":"Uses forsolver_kinds forunittest my_function7 forsolver program~~test_solver7~~UsesGraph program~test_solver7 test_solver7 forunittest forunittest program~test_solver7->forunittest module~forsolver forsolver program~test_solver7->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver7->module~forsolver_kinds module~my_function7 my_function7 program~test_solver7->module~my_function7 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function7->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver7~~CallsGraph program~test_solver7 test_solver7 check check program~test_solver7->check none~solve nlsolver%solve program~test_solver7->none~solve proc~set_options nlsolver%set_options program~test_solver7->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut complex(kind=rk) :: x Source Code program test_solver7 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function7 , only : F2 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ) :: x real ( rk ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs' ,& cs_tol = tiny ( 0.0_rk ),& maxit = 100 ,& TolFun = 1e-6_rk ,& verbosity = 0 ) call nls % solve ( F = F2 , x0 = ( 0.95_rk , 0.0_rk ), x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x % re , expected_x , 1.0e-4_rk , 'test_solver7' ) end program test_solver7","tags":"","url":"program/test_solver7.html"},{"title":"test_solver16 – ForSolver","text":"Uses forunittest forsolver program~~test_solver16~~UsesGraph program~test_solver16 test_solver16 forunittest forunittest program~test_solver16->forunittest module~forsolver forsolver program~test_solver16->module~forsolver fordiff fordiff module~forsolver->fordiff module~forsolver_kinds forsolver_kinds module~forsolver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver16~~CallsGraph program~test_solver16 test_solver16 check check program~test_solver16->check interface~solve solve program~test_solver16->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(4,4) :: A real(kind=rk), dimension(4) :: b real(kind=rk), dimension(4) :: expected_x type(unit_test) :: ut real(kind=rk), dimension(4) :: x Source Code program test_solver16 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension ( 4 , 4 ) :: A real ( rk ), dimension ( 4 ) :: b real ( rk ), dimension ( 4 ) :: x , expected_x type ( unit_test ) :: ut ! set the matrix A A ( 1 ,:) = [ 1.44_rk , - 7.84_rk , - 4.39_rk , 4.53_rk ] A ( 2 ,:) = [ - 9.96_rk , - 0.28_rk , - 3.24_rk , 3.83_rk ] A ( 3 ,:) = [ - 7.55_rk , 3.24_rk , 6.27_rk , - 6.64_rk ] A ( 4 ,:) = [ 8.34_rk , 8.09_rk , 5.28_rk , 2.06_rk ] ! set the right-hand side b = [ 8.58_rk , 8.26_rk , 8.48_rk , - 5.28_rk ] ! solve the system x = solve ( A , b ) ! X = solve(A, b, method='gesvs') ! expected result expected_x ( 1 ) = - 1.0544691129297037_rk expected_x ( 2 ) = - 1.9149827187319857_rk expected_x ( 3 ) = 2.9192679369935912_rk expected_x ( 4 ) = 1.7440523733249165_rk ! check the result call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver16' ) end program test_solver16","tags":"","url":"program/test_solver16.html"},{"title":"test_solver4 – ForSolver","text":"Uses forsolver_kinds my_function4 forunittest forsolver program~~test_solver4~~UsesGraph program~test_solver4 test_solver4 forunittest forunittest program~test_solver4->forunittest module~forsolver forsolver program~test_solver4->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver4->module~forsolver_kinds module~my_function4 my_function4 program~test_solver4->module~my_function4 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function4->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver4~~CallsGraph program~test_solver4 test_solver4 check check program~test_solver4->check none~solve nlsolver%solve program~test_solver4->none~solve proc~set_options nlsolver%set_options program~test_solver4->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk) :: x Source Code program test_solver4 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function4 , only : F1 , dF1dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-modified' ,& nmp = 2 ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , dFdx = dF1dx , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver4' ) end program test_solver4","tags":"","url":"program/test_solver4.html"},{"title":"test_solver3 – ForSolver","text":"Uses forsolver_kinds forunittest my_function3 forsolver program~~test_solver3~~UsesGraph program~test_solver3 test_solver3 forunittest forunittest program~test_solver3->forunittest module~forsolver forsolver program~test_solver3->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver3->module~forsolver_kinds module~my_function3 my_function3 program~test_solver3->module~my_function3 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function3->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver3~~CallsGraph program~test_solver3 test_solver3 check check program~test_solver3->check none~solve nlsolver%solve program~test_solver3->none~solve proc~set_options nlsolver%set_options program~test_solver3->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk) :: x Source Code program test_solver3 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function3 , only : F1 , dF1dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton' ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , dFdx = dF1dx , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver3' ) end program test_solver3","tags":"","url":"program/test_solver3.html"},{"title":"test_solver13 – ForSolver","text":"Uses forsolver_kinds forunittest forsolver my_function13 program~~test_solver13~~UsesGraph program~test_solver13 test_solver13 forunittest forunittest program~test_solver13->forunittest module~forsolver forsolver program~test_solver13->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver13->module~forsolver_kinds module~my_function13 my_function13 program~test_solver13->module~my_function13 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function13->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver13~~CallsGraph program~test_solver13 test_solver13 check check program~test_solver13->check none~solve nlsolver%solve program~test_solver13->none~solve proc~set_options nlsolver%set_options program~test_solver13->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(2) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut complex(kind=rk), dimension(2) :: x Source Code program test_solver13 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function13 , only : F4 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ), dimension ( 2 ) :: x real ( rk ), dimension ( 2 ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs' ,& cs_tol = tiny ( 0.0_rk ),& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F4 , x0 = [( 0.95_rk , 0.0_rk ) ,( 0.95_rk , 0.0_rk )], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( real ( x , rk ), expected_x , 1.0e-1_rk , 'test_solver13' ) ! call ut%check(x%re, expected_x, 1.0e-1_rk, 'test_solver13' ) end program test_solver13","tags":"","url":"program/test_solver13.html"},{"title":"test_solver1 – ForSolver","text":"Uses forunittest forsolver program~~test_solver1~~UsesGraph program~test_solver1 test_solver1 forunittest forunittest program~test_solver1->forunittest module~forsolver forsolver program~test_solver1->module~forsolver fordiff fordiff module~forsolver->fordiff module~forsolver_kinds forsolver_kinds module~forsolver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver1~~CallsGraph program~test_solver1 test_solver1 check check program~test_solver1->check interface~solve solve program~test_solver1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:,:), allocatable :: A real(kind=rk), dimension(:), allocatable :: b real(kind=rk), dimension(:), allocatable :: expected_x integer :: i integer :: j integer :: m integer :: n type(unit_test) :: ut real(kind=rk), dimension(:), allocatable :: x1 real(kind=rk), dimension(:), allocatable :: x2 Source Code program test_solver1 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension (:,:), allocatable :: A real ( rk ), dimension (:) , allocatable :: x1 , x2 , expected_x , b integer :: m , n , i , j type ( unit_test ) :: ut m = 3 n = 2 allocate ( A ( m , n ), b ( m ), x1 ( n ), x2 ( n ), expected_x ( n )) A ( 1 ,:) = [ 1.0_rk , 5.0_rk ] A ( 2 ,:) = [ 3.0_rk , 1.0_rk ] A ( 3 ,:) = [ - 2.0_rk , 4.0_rk ] b = [ 4.0_rk , - 2.0_rk , 3.0_rk ] expected_x = [ - 4.0_rk / 7.0_rk , 5.0_rk / 7.0_rk ] x1 = solve ( A , b ) ! check if solution is close to expected_x call ut % check ( x1 , expected_x , 1.0e-6_rk , 'test_solver1.1' ) x2 = solve ( A , b , method = 'gels' ) ! check if solution is close to expected_x call ut % check ( x2 , expected_x , 1.0e-6_rk , 'test_solver1.2' ) deallocate ( A , b , x1 , x2 , expected_x ) end program test_solver1","tags":"","url":"program/test_solver1.html"},{"title":"test_solver8 – ForSolver","text":"Uses forsolver_kinds forunittest my_function8 forsolver program~~test_solver8~~UsesGraph program~test_solver8 test_solver8 forunittest forunittest program~test_solver8->forunittest module~forsolver forsolver program~test_solver8->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver8->module~forsolver_kinds module~my_function8 my_function8 program~test_solver8->module~my_function8 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function8->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver8~~CallsGraph program~test_solver8 test_solver8 check check program~test_solver8->check none~solve nlsolver%solve program~test_solver8->none~solve proc~set_options nlsolver%set_options program~test_solver8->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut complex(kind=rk) :: x Source Code program test_solver8 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function8 , only : F2 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ) :: x real ( rk ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs-modified' ,& cs_tol = tiny ( 0.0_rk ),& nmp = 2 ,& maxit = 100 ,& TolFun = 1e-6_rk ,& verbosity = 0 ) call nls % solve ( F = F2 , x0 = ( 0.95_rk , 0.0_rk ), x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x % re , 0.53128_rk , 1.0e-4_rk , 'test_solver8' ) end program test_solver8","tags":"","url":"program/test_solver8.html"},{"title":"test_solver15 – ForSolver","text":"Uses forunittest forsolver program~~test_solver15~~UsesGraph program~test_solver15 test_solver15 forunittest forunittest program~test_solver15->forunittest module~forsolver forsolver program~test_solver15->module~forsolver fordiff fordiff module~forsolver->fordiff module~forsolver_kinds forsolver_kinds module~forsolver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver15~~CallsGraph program~test_solver15 test_solver15 check check program~test_solver15->check interface~solve solve program~test_solver15->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(6,4) :: A real(kind=rk), dimension(6) :: b real(kind=rk), dimension(4) :: expected_x type(unit_test) :: ut real(kind=rk), dimension(4) :: x Source Code program test_solver15 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension ( 6 , 4 ) :: A real ( rk ), dimension ( 6 ) :: b real ( rk ), dimension ( 4 ) :: x , expected_x type ( unit_test ) :: ut ! set the matrix A A ( 1 ,:) = [ 1.44_rk , - 7.84_rk , - 4.39_rk , 4.53_rk ] A ( 2 ,:) = [ - 9.96_rk , - 0.28_rk , - 3.24_rk , 3.83_rk ] A ( 3 ,:) = [ - 7.55_rk , 3.24_rk , 6.27_rk , - 6.64_rk ] A ( 4 ,:) = [ 8.34_rk , 8.09_rk , 5.28_rk , 2.06_rk ] A ( 5 ,:) = [ 7.08_rk , 2.52_rk , 0.74_rk , - 2.47_rk ] A ( 6 ,:) = [ - 5.45_rk , - 5.70_rk , - 1.19_rk , 4.70_rk ] ! set the right-hand side b = [ 8.58_rk , 8.26_rk , 8.48_rk , - 5.28_rk , 5.72_rk , 8.93_rk ] ! solve the system x = solve ( A , b ) ! X = solve(A, b, method='gels') ! expected result expected_x ( 1 ) = - 0.45063713541953410_rk expected_x ( 2 ) = - 0.84915021471399577_rk expected_x ( 3 ) = 0.70661216240939595_rk expected_x ( 4 ) = 0.12888575215577794_rk ! check the result call ut % check ( x , expected_x , 1.0e-6_rk , 'test_solver15' ) end program test_solver15","tags":"","url":"program/test_solver15.html"},{"title":"test_solver6 – ForSolver","text":"Uses forsolver_kinds forunittest forsolver my_function6 program~~test_solver6~~UsesGraph program~test_solver6 test_solver6 forunittest forunittest program~test_solver6->forunittest module~forsolver forsolver program~test_solver6->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver6->module~forsolver_kinds module~my_function6 my_function6 program~test_solver6->module~my_function6 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function6->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver6~~CallsGraph program~test_solver6 test_solver6 check check program~test_solver6->check none~solve nlsolver%solve program~test_solver6->none~solve proc~set_options nlsolver%set_options program~test_solver6->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk) :: x Source Code program test_solver6 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function6 , only : F1 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd-modified' ,& fdm_method = 'central' ,& fdm_tol = 1e-6_rk ,& nmp = 2 ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver6' ) end program test_solver6","tags":"","url":"program/test_solver6.html"},{"title":"test_solver17 – ForSolver","text":"Uses forunittest forsolver program~~test_solver17~~UsesGraph program~test_solver17 test_solver17 forunittest forunittest program~test_solver17->forunittest module~forsolver forsolver program~test_solver17->module~forsolver fordiff fordiff module~forsolver->fordiff module~forsolver_kinds forsolver_kinds module~forsolver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver17~~CallsGraph program~test_solver17 test_solver17 check check program~test_solver17->check interface~solve solve program~test_solver17->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(4,4) :: A real(kind=rk), dimension(4) :: b real(kind=rk), dimension(4) :: expected_x type(unit_test) :: ut real(kind=rk), dimension(4) :: x Source Code program test_solver17 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension ( 4 , 4 ) :: A real ( rk ), dimension ( 4 ) :: b real ( rk ), dimension ( 4 ) :: x , expected_x type ( unit_test ) :: ut ! set the matrix A A ( 1 ,:) = [ 1.44_rk , - 7.84_rk , - 4.39_rk , 4.53_rk ] A ( 2 ,:) = [ - 9.96_rk , - 0.28_rk , - 3.24_rk , 3.83_rk ] A ( 3 ,:) = [ - 7.55_rk , 3.24_rk , 6.27_rk , - 6.64_rk ] A ( 4 ,:) = [ 8.34_rk , 8.09_rk , 5.28_rk , 2.06_rk ] ! set the right-hand side b = [ 8.58_rk , 8.26_rk , 8.48_rk , - 5.28_rk ] ! solve the system x = solve ( A , b , method = 'gels' ) ! expected result expected_x ( 1 ) = - 1.0544691129297037_rk expected_x ( 2 ) = - 1.9149827187319857_rk expected_x ( 3 ) = 2.9192679369935912_rk expected_x ( 4 ) = 1.7440523733249165_rk ! check the result call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver17' ) end program test_solver17","tags":"","url":"program/test_solver17.html"},{"title":"test_solver12 – ForSolver","text":"Uses forsolver_kinds forunittest forsolver my_function12 program~~test_solver12~~UsesGraph program~test_solver12 test_solver12 forunittest forunittest program~test_solver12->forunittest module~forsolver forsolver program~test_solver12->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver12->module~forsolver_kinds module~my_function12 my_function12 program~test_solver12->module~my_function12 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function12->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver12~~CallsGraph program~test_solver12 test_solver12 check check program~test_solver12->check none~solve nlsolver%solve program~test_solver12->none~solve proc~set_options nlsolver%set_options program~test_solver12->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(2) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk), dimension(2) :: x Source Code program test_solver12 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function12 , only : F3 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd-modified' ,& fdm_method = 'central' ,& fdm_tol = 1e-7_rk ,& nmp = 1 ,& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-1_rk , 'test_solver12' ) end program test_solver12","tags":"","url":"program/test_solver12.html"},{"title":"test_solver5 – ForSolver","text":"Uses forsolver_kinds forunittest forsolver my_function5 program~~test_solver5~~UsesGraph program~test_solver5 test_solver5 forunittest forunittest program~test_solver5->forunittest module~forsolver forsolver program~test_solver5->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver5->module~forsolver_kinds module~my_function5 my_function5 program~test_solver5->module~my_function5 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function5->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver5~~CallsGraph program~test_solver5 test_solver5 check check program~test_solver5->check none~solve nlsolver%solve program~test_solver5->none~solve proc~set_options nlsolver%set_options program~test_solver5->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk) :: x Source Code program test_solver5 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function5 , only : F1 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd' ,& fdm_method = 'central' ,& fdm_tol = 1e-6_rk ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver5' ) end program test_solver5","tags":"","url":"program/test_solver5.html"},{"title":"test_solver2 – ForSolver","text":"Uses forunittest forsolver program~~test_solver2~~UsesGraph program~test_solver2 test_solver2 forunittest forunittest program~test_solver2->forunittest module~forsolver forsolver program~test_solver2->module~forsolver fordiff fordiff module~forsolver->fordiff module~forsolver_kinds forsolver_kinds module~forsolver->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver2~~CallsGraph program~test_solver2 test_solver2 check check program~test_solver2->check interface~solve solve program~test_solver2->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:,:), allocatable :: A real(kind=rk), dimension(:), allocatable :: b real(kind=rk), dimension(:), allocatable :: expected_x integer :: i integer :: j integer :: m integer :: n type(unit_test) :: ut real(kind=rk), dimension(:), allocatable :: x1 real(kind=rk), dimension(:), allocatable :: x2 real(kind=rk), dimension(:), allocatable :: x3 Source Code program test_solver2 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension (:,:), allocatable :: A real ( rk ), dimension (:) , allocatable :: x1 , x2 , x3 , expected_x , b integer :: m , n , i , j type ( unit_test ) :: ut m = 4 n = 4 allocate ( A ( m , n ), b ( m ), x1 ( n ), x2 ( n ), x3 ( n ), expected_x ( n )) A ( 1 ,:) = [ 1.0_rk , 1.0_rk , - 3.0_rk , 1.0_rk ] A ( 2 ,:) = [ - 5.0_rk , 3.0_rk , - 4.0_rk , 1.0_rk ] A ( 3 ,:) = [ 1.0_rk , 0.0_rk , 2.0_rk , - 1.0_rk ] A ( 4 ,:) = [ 1.0_rk , 2.0_rk , 0.0_rk , 0.0_rk ] b = [ 2.0_rk , 0.0_rk , 1.0_rk , 1 2.0_rk ] expected_x = [ 2 2.0_rk / 1 7.0_rk , 9 1.0_rk / 1 7.0_rk , 8 4.0_rk / 1 7.0_rk , 17 3.0_rk / 1 7.0_rk ] x1 = solve ( A , b ) ! check if solution is close to expected_x call ut % check ( x1 , expected_x , 1.0e-6_rk , 'test_solver2.1' ) x2 = solve ( A , b , method = 'gesv' ) ! check if solution is close to expected_x call ut % check ( x2 , expected_x , 1.0e-6_rk , 'test_solver2.2' ) x3 = solve ( A , b , method = 'gels' ) ! check if solution is close to expected_x call ut % check ( x3 , expected_x , 1.0e-6_rk , 'test_solver2.3' ) deallocate ( A , b , x1 , x2 , x3 , expected_x ) end program test_solver2","tags":"","url":"program/test_solver2.html"},{"title":"test_solver11 – ForSolver","text":"Uses forsolver_kinds my_function11 forunittest forsolver program~~test_solver11~~UsesGraph program~test_solver11 test_solver11 forunittest forunittest program~test_solver11->forunittest module~forsolver forsolver program~test_solver11->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver11->module~forsolver_kinds module~my_function11 my_function11 program~test_solver11->module~my_function11 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function11->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver11~~CallsGraph program~test_solver11 test_solver11 check check program~test_solver11->check none~solve nlsolver%solve program~test_solver11->none~solve proc~set_options nlsolver%set_options program~test_solver11->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(2) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk), dimension(2) :: x Source Code program test_solver11 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function11 , only : F3 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd' ,& fdm_method = 'central' ,& fdm_tol = 1e-7_rk ,& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-1_rk , 'test_solver11' ) end program test_solver11","tags":"","url":"program/test_solver11.html"},{"title":"test_solver10 – ForSolver","text":"Uses forsolver_kinds my_function10 forunittest forsolver program~~test_solver10~~UsesGraph program~test_solver10 test_solver10 forunittest forunittest program~test_solver10->forunittest module~forsolver forsolver program~test_solver10->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver10->module~forsolver_kinds module~my_function10 my_function10 program~test_solver10->module~my_function10 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function10->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver10~~CallsGraph program~test_solver10 test_solver10 check check program~test_solver10->check none~solve nlsolver%solve program~test_solver10->none~solve proc~set_options nlsolver%set_options program~test_solver10->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(2) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk), dimension(2) :: x Source Code program test_solver10 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function10 , only : F3 , dF3dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-modified' ,& nmp = 1 ,& maxit = 100 ,& TolFun = 1e-15_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , dFdx = dF3dx , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver10' ) end program test_solver10","tags":"","url":"program/test_solver10.html"},{"title":"test_solver9 – ForSolver","text":"Uses my_function9 forsolver_kinds forunittest forsolver program~~test_solver9~~UsesGraph program~test_solver9 test_solver9 forunittest forunittest program~test_solver9->forunittest module~forsolver forsolver program~test_solver9->module~forsolver module~forsolver_kinds forsolver_kinds program~test_solver9->module~forsolver_kinds module~my_function9 my_function9 program~test_solver9->module~my_function9 module~forsolver->module~forsolver_kinds fordiff fordiff module~forsolver->fordiff module~my_function9->module~forsolver_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_solver9~~CallsGraph program~test_solver9 test_solver9 check check program~test_solver9->check none~solve nlsolver%solve program~test_solver9->none~solve proc~set_options nlsolver%set_options program~test_solver9->proc~set_options proc~newton_complex_step_rel_t0 nlsolver%newton_complex_step_rel_T0 none~solve->proc~newton_complex_step_rel_t0 proc~newton_complex_step_rel_t1 nlsolver%newton_complex_step_rel_T1 none~solve->proc~newton_complex_step_rel_t1 proc~newton_rel_t0 nlsolver%newton_rel_T0 none~solve->proc~newton_rel_t0 proc~newton_rel_t1 nlsolver%newton_rel_T1 none~solve->proc~newton_rel_t1 proc~modified_quasi_cs_newton_method_t0 modified_quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~modified_quasi_cs_newton_method_t0 proc~quasi_cs_newton_method_t0 quasi_cs_newton_method_T0 proc~newton_complex_step_rel_t0->proc~quasi_cs_newton_method_t0 proc~modified_quasi_cs_newton_method_t1 modified_quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~modified_quasi_cs_newton_method_t1 proc~quasi_cs_newton_method_t1 quasi_cs_newton_method_T1 proc~newton_complex_step_rel_t1->proc~quasi_cs_newton_method_t1 proc~modified_newton_method_t0 modified_newton_method_T0 proc~newton_rel_t0->proc~modified_newton_method_t0 proc~modified_quasi_fd_newton_method_t0 modified_quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~modified_quasi_fd_newton_method_t0 proc~newton_method_t0 newton_method_T0 proc~newton_rel_t0->proc~newton_method_t0 proc~quasi_fd_newton_method_t0 quasi_fd_newton_method_T0 proc~newton_rel_t0->proc~quasi_fd_newton_method_t0 proc~modified_newton_method_t1 modified_newton_method_T1 proc~newton_rel_t1->proc~modified_newton_method_t1 proc~modified_quasi_fd_newton_method_t1 modified_quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~modified_quasi_fd_newton_method_t1 proc~newton_method_t1 newton_method_T1 proc~newton_rel_t1->proc~newton_method_t1 proc~quasi_fd_newton_method_t1 quasi_fd_newton_method_T1 proc~newton_rel_t1->proc~quasi_fd_newton_method_t1 interface~solve solve proc~modified_newton_method_t1->interface~solve derivative derivative proc~modified_quasi_cs_newton_method_t0->derivative proc~modified_quasi_cs_newton_method_t1->derivative proc~modified_quasi_cs_newton_method_t1->interface~solve proc~modified_quasi_fd_newton_method_t0->derivative proc~modified_quasi_fd_newton_method_t1->derivative proc~modified_quasi_fd_newton_method_t1->interface~solve proc~newton_method_t1->interface~solve proc~quasi_cs_newton_method_t0->derivative proc~quasi_cs_newton_method_t1->derivative proc~quasi_cs_newton_method_t1->interface~solve proc~quasi_fd_newton_method_t0->derivative proc~quasi_fd_newton_method_t1->derivative proc~quasi_fd_newton_method_t1->interface~solve proc~solver_lin solver_lin interface~solve->proc~solver_lin proc~gels_rel gels_rel proc~solver_lin->proc~gels_rel proc~gesv_rel gesv_rel proc~solver_lin->proc~gesv_rel interface~gels gels proc~gels_rel->interface~gels interface~gesv gesv proc~gesv_rel->interface~gesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(2) :: expected_x type( nlsolver ) :: nls type(unit_test) :: ut real(kind=rk), dimension(2) :: x Source Code program test_solver9 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function9 , only : F3 , dF3dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton' ,& maxit = 100 ,& TolFun = 1e-15_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , dFdx = dF3dx , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver9' ) end program test_solver9","tags":"","url":"program/test_solver9.html"},{"title":"test_solver14.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver14.f90~~EfferentGraph sourcefile~test_solver14.f90 test_solver14.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver14.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver14.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function14 use forsolver_kinds , only : rk implicit none contains function F4 ( x ) result ( F_val ) complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F4 end module my_function14 program test_solver14 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function14 , only : F4 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ), dimension ( 2 ) :: x real ( rk ), dimension ( 2 ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs-modified' ,& cs_tol = tiny ( 0.0_rk ),& nmp = 1 ,& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F4 , x0 = [( 0.95_rk , 0.0_rk ) ,( 0.95_rk , 0.0_rk )], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( real ( x , rk ), expected_x , 1.0e-1_rk , 'test_solver14' ) ! call ut%check(x%re, expected_x, 1.0e-1_rk, 'test_solver14' ) end program test_solver14","tags":"","url":"sourcefile/test_solver14.f90.html"},{"title":"test_solver7.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver7.f90~~EfferentGraph sourcefile~test_solver7.f90 test_solver7.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver7.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver7.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function7 use forsolver_kinds , only : rk implicit none contains function F2 ( x ) result ( F_val ) complex ( rk ), intent ( in ) :: x complex ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F2 end module my_function7 program test_solver7 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function7 , only : F2 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ) :: x real ( rk ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs' ,& cs_tol = tiny ( 0.0_rk ),& maxit = 100 ,& TolFun = 1e-6_rk ,& verbosity = 0 ) call nls % solve ( F = F2 , x0 = ( 0.95_rk , 0.0_rk ), x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x % re , expected_x , 1.0e-4_rk , 'test_solver7' ) end program test_solver7","tags":"","url":"sourcefile/test_solver7.f90.html"},{"title":"test_solver16.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver16.f90~~EfferentGraph sourcefile~test_solver16.f90 test_solver16.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver16.f90->sourcefile~forsolver.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_solver16 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension ( 4 , 4 ) :: A real ( rk ), dimension ( 4 ) :: b real ( rk ), dimension ( 4 ) :: x , expected_x type ( unit_test ) :: ut ! set the matrix A A ( 1 ,:) = [ 1.44_rk , - 7.84_rk , - 4.39_rk , 4.53_rk ] A ( 2 ,:) = [ - 9.96_rk , - 0.28_rk , - 3.24_rk , 3.83_rk ] A ( 3 ,:) = [ - 7.55_rk , 3.24_rk , 6.27_rk , - 6.64_rk ] A ( 4 ,:) = [ 8.34_rk , 8.09_rk , 5.28_rk , 2.06_rk ] ! set the right-hand side b = [ 8.58_rk , 8.26_rk , 8.48_rk , - 5.28_rk ] ! solve the system x = solve ( A , b ) ! X = solve(A, b, method='gesvs') ! expected result expected_x ( 1 ) = - 1.0544691129297037_rk expected_x ( 2 ) = - 1.9149827187319857_rk expected_x ( 3 ) = 2.9192679369935912_rk expected_x ( 4 ) = 1.7440523733249165_rk ! check the result call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver16' ) end program test_solver16","tags":"","url":"sourcefile/test_solver16.f90.html"},{"title":"test_solver4.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver4.f90~~EfferentGraph sourcefile~test_solver4.f90 test_solver4.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver4.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver4.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function4 use forsolver_kinds , only : rk implicit none contains function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1 function dF1dx ( x ) result ( dFdx_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: dFdx_val dFdx_val = 1 5.0_rk * x ** 2 + 8.0_rk end function dF1dx end module my_function4 program test_solver4 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function4 , only : F1 , dF1dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-modified' ,& nmp = 2 ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , dFdx = dF1dx , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver4' ) end program test_solver4","tags":"","url":"sourcefile/test_solver4.f90.html"},{"title":"forsolver_kinds.F90 – ForSolver","text":"Files dependent on this one sourcefile~~forsolver_kinds.f90~~AfferentGraph sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~test_solver10.f90 test_solver10.f90 sourcefile~test_solver10.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver10.f90->sourcefile~forsolver.f90 sourcefile~test_solver11.f90 test_solver11.f90 sourcefile~test_solver11.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver11.f90->sourcefile~forsolver.f90 sourcefile~test_solver12.f90 test_solver12.f90 sourcefile~test_solver12.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver12.f90->sourcefile~forsolver.f90 sourcefile~test_solver13.f90 test_solver13.f90 sourcefile~test_solver13.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver13.f90->sourcefile~forsolver.f90 sourcefile~test_solver14.f90 test_solver14.f90 sourcefile~test_solver14.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver14.f90->sourcefile~forsolver.f90 sourcefile~test_solver3.f90 test_solver3.f90 sourcefile~test_solver3.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver3.f90->sourcefile~forsolver.f90 sourcefile~test_solver4.f90 test_solver4.f90 sourcefile~test_solver4.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver4.f90->sourcefile~forsolver.f90 sourcefile~test_solver5.f90 test_solver5.f90 sourcefile~test_solver5.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver5.f90->sourcefile~forsolver.f90 sourcefile~test_solver6.f90 test_solver6.f90 sourcefile~test_solver6.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver6.f90->sourcefile~forsolver.f90 sourcefile~test_solver7.f90 test_solver7.f90 sourcefile~test_solver7.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver7.f90->sourcefile~forsolver.f90 sourcefile~test_solver8.f90 test_solver8.f90 sourcefile~test_solver8.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver8.f90->sourcefile~forsolver.f90 sourcefile~test_solver9.f90 test_solver9.f90 sourcefile~test_solver9.f90->sourcefile~forsolver_kinds.f90 sourcefile~test_solver9.f90->sourcefile~forsolver.f90 sourcefile~test_solver1.f90 test_solver1.f90 sourcefile~test_solver1.f90->sourcefile~forsolver.f90 sourcefile~test_solver15.f90 test_solver15.f90 sourcefile~test_solver15.f90->sourcefile~forsolver.f90 sourcefile~test_solver16.f90 test_solver16.f90 sourcefile~test_solver16.f90->sourcefile~forsolver.f90 sourcefile~test_solver17.f90 test_solver17.f90 sourcefile~test_solver17.f90->sourcefile~forsolver.f90 sourcefile~test_solver2.f90 test_solver2.f90 sourcefile~test_solver2.f90->sourcefile~forsolver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause module forsolver_kinds implicit none private public rk #ifdef REAL32 integer , parameter :: rk = selected_real_kind ( 6 ) #elif REAL64 integer , parameter :: rk = selected_real_kind ( 15 ) #elif REALXDP integer , parameter :: rk = selected_real_kind ( 18 ) #elif REAL128 integer , parameter :: rk = selected_real_kind ( 33 ) #else integer , parameter :: rk = selected_real_kind ( 15 ) #endif end module","tags":"","url":"sourcefile/forsolver_kinds.f90.html"},{"title":"test_solver3.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver3.f90~~EfferentGraph sourcefile~test_solver3.f90 test_solver3.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver3.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver3.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function3 use forsolver_kinds , only : rk implicit none contains function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1 function dF1dx ( x ) result ( dFdx_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: dFdx_val dFdx_val = 1 5.0_rk * x ** 2 + 8.0_rk end function dF1dx end module my_function3 program test_solver3 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function3 , only : F1 , dF1dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton' ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , dFdx = dF1dx , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver3' ) end program test_solver3","tags":"","url":"sourcefile/test_solver3.f90.html"},{"title":"test_solver13.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver13.f90~~EfferentGraph sourcefile~test_solver13.f90 test_solver13.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver13.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver13.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function13 use forsolver_kinds , only : rk implicit none contains function F4 ( x ) result ( F_val ) complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F4 end module my_function13 program test_solver13 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function13 , only : F4 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ), dimension ( 2 ) :: x real ( rk ), dimension ( 2 ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs' ,& cs_tol = tiny ( 0.0_rk ),& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F4 , x0 = [( 0.95_rk , 0.0_rk ) ,( 0.95_rk , 0.0_rk )], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( real ( x , rk ), expected_x , 1.0e-1_rk , 'test_solver13' ) ! call ut%check(x%re, expected_x, 1.0e-1_rk, 'test_solver13' ) end program test_solver13","tags":"","url":"sourcefile/test_solver13.f90.html"},{"title":"test_solver1.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver1.f90~~EfferentGraph sourcefile~test_solver1.f90 test_solver1.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver1.f90->sourcefile~forsolver.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_solver1 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension (:,:), allocatable :: A real ( rk ), dimension (:) , allocatable :: x1 , x2 , expected_x , b integer :: m , n , i , j type ( unit_test ) :: ut m = 3 n = 2 allocate ( A ( m , n ), b ( m ), x1 ( n ), x2 ( n ), expected_x ( n )) A ( 1 ,:) = [ 1.0_rk , 5.0_rk ] A ( 2 ,:) = [ 3.0_rk , 1.0_rk ] A ( 3 ,:) = [ - 2.0_rk , 4.0_rk ] b = [ 4.0_rk , - 2.0_rk , 3.0_rk ] expected_x = [ - 4.0_rk / 7.0_rk , 5.0_rk / 7.0_rk ] x1 = solve ( A , b ) ! check if solution is close to expected_x call ut % check ( x1 , expected_x , 1.0e-6_rk , 'test_solver1.1' ) x2 = solve ( A , b , method = 'gels' ) ! check if solution is close to expected_x call ut % check ( x2 , expected_x , 1.0e-6_rk , 'test_solver1.2' ) deallocate ( A , b , x1 , x2 , expected_x ) end program test_solver1","tags":"","url":"sourcefile/test_solver1.f90.html"},{"title":"test_solver8.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver8.f90~~EfferentGraph sourcefile~test_solver8.f90 test_solver8.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver8.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver8.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function8 use forsolver_kinds , only : rk implicit none contains function F2 ( x ) result ( F_val ) complex ( rk ), intent ( in ) :: x complex ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F2 end module my_function8 program test_solver8 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function8 , only : F2 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls complex ( rk ) :: x real ( rk ) :: expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-cs-modified' ,& cs_tol = tiny ( 0.0_rk ),& nmp = 2 ,& maxit = 100 ,& TolFun = 1e-6_rk ,& verbosity = 0 ) call nls % solve ( F = F2 , x0 = ( 0.95_rk , 0.0_rk ), x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x % re , 0.53128_rk , 1.0e-4_rk , 'test_solver8' ) end program test_solver8","tags":"","url":"sourcefile/test_solver8.f90.html"},{"title":"test_solver15.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver15.f90~~EfferentGraph sourcefile~test_solver15.f90 test_solver15.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver15.f90->sourcefile~forsolver.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_solver15 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension ( 6 , 4 ) :: A real ( rk ), dimension ( 6 ) :: b real ( rk ), dimension ( 4 ) :: x , expected_x type ( unit_test ) :: ut ! set the matrix A A ( 1 ,:) = [ 1.44_rk , - 7.84_rk , - 4.39_rk , 4.53_rk ] A ( 2 ,:) = [ - 9.96_rk , - 0.28_rk , - 3.24_rk , 3.83_rk ] A ( 3 ,:) = [ - 7.55_rk , 3.24_rk , 6.27_rk , - 6.64_rk ] A ( 4 ,:) = [ 8.34_rk , 8.09_rk , 5.28_rk , 2.06_rk ] A ( 5 ,:) = [ 7.08_rk , 2.52_rk , 0.74_rk , - 2.47_rk ] A ( 6 ,:) = [ - 5.45_rk , - 5.70_rk , - 1.19_rk , 4.70_rk ] ! set the right-hand side b = [ 8.58_rk , 8.26_rk , 8.48_rk , - 5.28_rk , 5.72_rk , 8.93_rk ] ! solve the system x = solve ( A , b ) ! X = solve(A, b, method='gels') ! expected result expected_x ( 1 ) = - 0.45063713541953410_rk expected_x ( 2 ) = - 0.84915021471399577_rk expected_x ( 3 ) = 0.70661216240939595_rk expected_x ( 4 ) = 0.12888575215577794_rk ! check the result call ut % check ( x , expected_x , 1.0e-6_rk , 'test_solver15' ) end program test_solver15","tags":"","url":"sourcefile/test_solver15.f90.html"},{"title":"test_solver6.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver6.f90~~EfferentGraph sourcefile~test_solver6.f90 test_solver6.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver6.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver6.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function6 use forsolver_kinds , only : rk implicit none contains function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1 end module my_function6 program test_solver6 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function6 , only : F1 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd-modified' ,& fdm_method = 'central' ,& fdm_tol = 1e-6_rk ,& nmp = 2 ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver6' ) end program test_solver6","tags":"","url":"sourcefile/test_solver6.f90.html"},{"title":"test_solver17.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver17.f90~~EfferentGraph sourcefile~test_solver17.f90 test_solver17.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver17.f90->sourcefile~forsolver.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_solver17 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension ( 4 , 4 ) :: A real ( rk ), dimension ( 4 ) :: b real ( rk ), dimension ( 4 ) :: x , expected_x type ( unit_test ) :: ut ! set the matrix A A ( 1 ,:) = [ 1.44_rk , - 7.84_rk , - 4.39_rk , 4.53_rk ] A ( 2 ,:) = [ - 9.96_rk , - 0.28_rk , - 3.24_rk , 3.83_rk ] A ( 3 ,:) = [ - 7.55_rk , 3.24_rk , 6.27_rk , - 6.64_rk ] A ( 4 ,:) = [ 8.34_rk , 8.09_rk , 5.28_rk , 2.06_rk ] ! set the right-hand side b = [ 8.58_rk , 8.26_rk , 8.48_rk , - 5.28_rk ] ! solve the system x = solve ( A , b , method = 'gels' ) ! expected result expected_x ( 1 ) = - 1.0544691129297037_rk expected_x ( 2 ) = - 1.9149827187319857_rk expected_x ( 3 ) = 2.9192679369935912_rk expected_x ( 4 ) = 1.7440523733249165_rk ! check the result call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver17' ) end program test_solver17","tags":"","url":"sourcefile/test_solver17.f90.html"},{"title":"external_interfaces.f90 – ForSolver","text":"This file depends on sourcefile~~external_interfaces.f90~~EfferentGraph sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~external_interfaces.f90~~AfferentGraph sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~test_solver1.f90 test_solver1.f90 sourcefile~test_solver1.f90->sourcefile~forsolver.f90 sourcefile~test_solver10.f90 test_solver10.f90 sourcefile~test_solver10.f90->sourcefile~forsolver.f90 sourcefile~test_solver11.f90 test_solver11.f90 sourcefile~test_solver11.f90->sourcefile~forsolver.f90 sourcefile~test_solver12.f90 test_solver12.f90 sourcefile~test_solver12.f90->sourcefile~forsolver.f90 sourcefile~test_solver13.f90 test_solver13.f90 sourcefile~test_solver13.f90->sourcefile~forsolver.f90 sourcefile~test_solver14.f90 test_solver14.f90 sourcefile~test_solver14.f90->sourcefile~forsolver.f90 sourcefile~test_solver15.f90 test_solver15.f90 sourcefile~test_solver15.f90->sourcefile~forsolver.f90 sourcefile~test_solver16.f90 test_solver16.f90 sourcefile~test_solver16.f90->sourcefile~forsolver.f90 sourcefile~test_solver17.f90 test_solver17.f90 sourcefile~test_solver17.f90->sourcefile~forsolver.f90 sourcefile~test_solver2.f90 test_solver2.f90 sourcefile~test_solver2.f90->sourcefile~forsolver.f90 sourcefile~test_solver3.f90 test_solver3.f90 sourcefile~test_solver3.f90->sourcefile~forsolver.f90 sourcefile~test_solver4.f90 test_solver4.f90 sourcefile~test_solver4.f90->sourcefile~forsolver.f90 sourcefile~test_solver5.f90 test_solver5.f90 sourcefile~test_solver5.f90->sourcefile~forsolver.f90 sourcefile~test_solver6.f90 test_solver6.f90 sourcefile~test_solver6.f90->sourcefile~forsolver.f90 sourcefile~test_solver7.f90 test_solver7.f90 sourcefile~test_solver7.f90->sourcefile~forsolver.f90 sourcefile~test_solver8.f90 test_solver8.f90 sourcefile~test_solver8.f90->sourcefile~forsolver.f90 sourcefile~test_solver9.f90 test_solver9.f90 sourcefile~test_solver9.f90->sourcefile~forsolver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module external_interfaces_solver use forsolver_kinds , only : rk implicit none interface gesv #if defined(REAL64) pure subroutine dgesv ( fn , fnrhs , fa , flda , fipiv , fb , fldb , finfo ) import rk implicit none integer , intent ( in ) :: fn , fnrhs , flda , fldb real ( rk ), intent ( inout ) :: fa ( flda , fn ), fb ( fldb , fnrhs ) integer , intent ( out ) :: finfo integer , intent ( out ) :: fipiv ( fn ) end subroutine dgesv #elif defined(REAL32) pure subroutine sgesv ( fn , fnrhs , fa , flda , fipiv , fb , fldb , finfo ) import rk implicit none integer , intent ( in ) :: fn , fnrhs , flda , fldb real ( rk ), intent ( inout ) :: fa ( flda , fn ), fb ( fldb , fnrhs ) integer , intent ( out ) :: finfo integer , intent ( out ) :: fipiv ( fn ) end subroutine sgesv #else pure subroutine dgesv ( fn , fnrhs , fa , flda , fipiv , fb , fldb , finfo ) import rk implicit none integer , intent ( in ) :: fn , fnrhs , flda , fldb real ( rk ), intent ( inout ) :: fa ( flda , fn ), fb ( fldb , fnrhs ) integer , intent ( out ) :: finfo integer , intent ( out ) :: fipiv ( fn ) end subroutine dgesv #endif end interface interface gels #if defined(REAL64) pure subroutine dgels ( ftrans , fm , fn , fnrhs , fa , flda , fb , fldb , fwork , flwork , finfo ) import :: rk character ( len = 1 ), intent ( in ) :: ftrans integer , intent ( in ) :: fm , fn , fnrhs , flda , fldb , flwork real ( rk ), intent ( inout ) :: fa ( flda , * ), fb ( fldb , * ) real ( rk ), intent ( in ) :: fwork ( * ) integer , intent ( out ) :: finfo end subroutine dgels #elif defined(REAL32) pure subroutine sgels ( ftrans , fm , fn , fnrhs , fa , flda , fb , fldb , fwork , flwork , finfo ) import :: rk character ( len = 1 ), intent ( in ) :: ftrans integer , intent ( in ) :: fm , fn , fnrhs , flda , fldb , flwork real ( rk ), intent ( inout ) :: fa ( flda , * ), fb ( fldb , * ) real ( rk ), intent ( in ) :: fwork ( * ) integer , intent ( out ) :: finfo end subroutine sgels #else pure subroutine dgels ( ftrans , fm , fn , fnrhs , fa , flda , fb , fldb , fwork , flwork , finfo ) import :: rk character ( len = 1 ), intent ( in ) :: ftrans integer , intent ( in ) :: fm , fn , fnrhs , flda , fldb , flwork real ( rk ), intent ( inout ) :: fa ( flda , * ), fb ( fldb , * ) real ( rk ), intent ( in ) :: fwork ( * ) integer , intent ( out ) :: finfo end subroutine dgels #endif end interface end module external_interfaces_solver","tags":"","url":"sourcefile/external_interfaces.f90.html"},{"title":"test_solver12.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver12.f90~~EfferentGraph sourcefile~test_solver12.f90 test_solver12.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver12.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver12.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function12 use forsolver_kinds , only : rk implicit none contains function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3 end module my_function12 program test_solver12 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function12 , only : F3 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd-modified' ,& fdm_method = 'central' ,& fdm_tol = 1e-7_rk ,& nmp = 1 ,& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-1_rk , 'test_solver12' ) end program test_solver12","tags":"","url":"sourcefile/test_solver12.f90.html"},{"title":"test_solver5.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver5.f90~~EfferentGraph sourcefile~test_solver5.f90 test_solver5.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver5.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver5.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function5 use forsolver_kinds , only : rk implicit none contains function F1 ( x ) result ( F_val ) real ( rk ), intent ( in ) :: x real ( rk ) :: F_val F_val = 5.0_rk * x ** 3 + 8.0_rk * x - 5.0_rk end function F1 end module my_function5 program test_solver5 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function5 , only : F1 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd' ,& fdm_method = 'central' ,& fdm_tol = 1e-6_rk ,& maxit = 100 ,& TolFun = 1e-4_rk ,& verbosity = 0 ) call nls % solve ( F = F1 , x0 = 1 0.0_rk , x_sol = x ) ! check if solution is close to ~=0.53128 expected_x = 0.53128_rk call ut % check ( x , expected_x , 1.0e-4_rk , 'test_solver5' ) end program test_solver5","tags":"","url":"sourcefile/test_solver5.f90.html"},{"title":"test_solver2.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver2.f90~~EfferentGraph sourcefile~test_solver2.f90 test_solver2.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver2.f90->sourcefile~forsolver.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_solver2 use forsolver , only : rk , solve use forunittest , only : unit_test implicit none real ( rk ), dimension (:,:), allocatable :: A real ( rk ), dimension (:) , allocatable :: x1 , x2 , x3 , expected_x , b integer :: m , n , i , j type ( unit_test ) :: ut m = 4 n = 4 allocate ( A ( m , n ), b ( m ), x1 ( n ), x2 ( n ), x3 ( n ), expected_x ( n )) A ( 1 ,:) = [ 1.0_rk , 1.0_rk , - 3.0_rk , 1.0_rk ] A ( 2 ,:) = [ - 5.0_rk , 3.0_rk , - 4.0_rk , 1.0_rk ] A ( 3 ,:) = [ 1.0_rk , 0.0_rk , 2.0_rk , - 1.0_rk ] A ( 4 ,:) = [ 1.0_rk , 2.0_rk , 0.0_rk , 0.0_rk ] b = [ 2.0_rk , 0.0_rk , 1.0_rk , 1 2.0_rk ] expected_x = [ 2 2.0_rk / 1 7.0_rk , 9 1.0_rk / 1 7.0_rk , 8 4.0_rk / 1 7.0_rk , 17 3.0_rk / 1 7.0_rk ] x1 = solve ( A , b ) ! check if solution is close to expected_x call ut % check ( x1 , expected_x , 1.0e-6_rk , 'test_solver2.1' ) x2 = solve ( A , b , method = 'gesv' ) ! check if solution is close to expected_x call ut % check ( x2 , expected_x , 1.0e-6_rk , 'test_solver2.2' ) x3 = solve ( A , b , method = 'gels' ) ! check if solution is close to expected_x call ut % check ( x3 , expected_x , 1.0e-6_rk , 'test_solver2.3' ) deallocate ( A , b , x1 , x2 , x3 , expected_x ) end program test_solver2","tags":"","url":"sourcefile/test_solver2.f90.html"},{"title":"test_solver11.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver11.f90~~EfferentGraph sourcefile~test_solver11.f90 test_solver11.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver11.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver11.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function11 use forsolver_kinds , only : rk implicit none contains function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3 end module my_function11 program test_solver11 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function11 , only : F3 use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-quasi-fd' ,& fdm_method = 'central' ,& fdm_tol = 1e-7_rk ,& maxit = 1000 ,& TolFun = 1e-2_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-1_rk , 'test_solver11' ) end program test_solver11","tags":"","url":"sourcefile/test_solver11.f90.html"},{"title":"forsolver.f90 – ForSolver","text":"This file depends on sourcefile~~forsolver.f90~~EfferentGraph sourcefile~forsolver.f90 forsolver.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forsolver.f90~~AfferentGraph sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver1.f90 test_solver1.f90 sourcefile~test_solver1.f90->sourcefile~forsolver.f90 sourcefile~test_solver10.f90 test_solver10.f90 sourcefile~test_solver10.f90->sourcefile~forsolver.f90 sourcefile~test_solver11.f90 test_solver11.f90 sourcefile~test_solver11.f90->sourcefile~forsolver.f90 sourcefile~test_solver12.f90 test_solver12.f90 sourcefile~test_solver12.f90->sourcefile~forsolver.f90 sourcefile~test_solver13.f90 test_solver13.f90 sourcefile~test_solver13.f90->sourcefile~forsolver.f90 sourcefile~test_solver14.f90 test_solver14.f90 sourcefile~test_solver14.f90->sourcefile~forsolver.f90 sourcefile~test_solver15.f90 test_solver15.f90 sourcefile~test_solver15.f90->sourcefile~forsolver.f90 sourcefile~test_solver16.f90 test_solver16.f90 sourcefile~test_solver16.f90->sourcefile~forsolver.f90 sourcefile~test_solver17.f90 test_solver17.f90 sourcefile~test_solver17.f90->sourcefile~forsolver.f90 sourcefile~test_solver2.f90 test_solver2.f90 sourcefile~test_solver2.f90->sourcefile~forsolver.f90 sourcefile~test_solver3.f90 test_solver3.f90 sourcefile~test_solver3.f90->sourcefile~forsolver.f90 sourcefile~test_solver4.f90 test_solver4.f90 sourcefile~test_solver4.f90->sourcefile~forsolver.f90 sourcefile~test_solver5.f90 test_solver5.f90 sourcefile~test_solver5.f90->sourcefile~forsolver.f90 sourcefile~test_solver6.f90 test_solver6.f90 sourcefile~test_solver6.f90->sourcefile~forsolver.f90 sourcefile~test_solver7.f90 test_solver7.f90 sourcefile~test_solver7.f90->sourcefile~forsolver.f90 sourcefile~test_solver8.f90 test_solver8.f90 sourcefile~test_solver8.f90->sourcefile~forsolver.f90 sourcefile~test_solver9.f90 test_solver9.f90 sourcefile~test_solver9.f90->sourcefile~forsolver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forsolver ! This module provides functions and subroutines for ! solving linear systems and performing Newton's method. use forsolver_kinds , only : rk use fordiff , only : derivative implicit none private public :: rk , solve , nlsolver type :: nlsolver character (:), allocatable :: lin_method character (:), allocatable :: nl_method character (:), allocatable :: fdm_method real ( rk ) :: TolFun real ( rk ) :: fdm_tol real ( rk ) :: cs_tol integer :: maxit integer :: nmp integer :: verbosity ! character(:), allocatable :: stepsize ! real(rk)                  :: alpha0 ! real(rk)                  :: c1 ! real(rk)                  :: c2 contains procedure :: set_options procedure :: newton_rel_T0 procedure :: newton_rel_T1 procedure :: newton_complex_step_rel_T0 procedure :: newton_complex_step_rel_T1 generic :: solve => newton_rel_T0 ,& newton_rel_T1 ,& newton_complex_step_rel_T0 ,& newton_complex_step_rel_T1 final :: deallocate_solver end type nlsolver !=============================================================================== interface solve procedure :: solver_lin end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi pure function solver_lin ( A , b , method ) result ( x ) ! inputs real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b character ( * ), optional , intent ( in ) :: method ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))) :: x ! solution matrix x ! local variables integer :: info ! result info ! call solver if ( present ( method )) then select case ( method ) case ( 'gesv' ) call gesv_rel ( A , b , x , info ) case ( 'gels' ) call gels_rel ( A , b , x , info ) end select else if ( size ( A , 1 ) == size ( A , 2 )) then call gesv_rel ( A , b , x , info ) else call gels_rel ( A , b , x , info ) end if end if end function solver_lin !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine gesv_rel ( A , b , x , info ) use external_interfaces_solver , only : gesv ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables integer :: n , lda , ldb , nrhs integer , dimension ( size ( A , 2 )) :: ipiv real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! get dimensions nrhs = 1 ! size(b, 2) n = size ( A , 2 ) lda = max ( 1 , n ) ldb = max ( 1 , n ) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! call gels subroutine call gesv ( n , nrhs , a_copy , lda , ipiv , b_copy , ldb , info ) ! copy the solution matrix if ( info == 0 ) then x = b_copy ( 1 : ldb , 1 ) ! nrhs = 1 else error stop 'gesv failed' end if end subroutine gesv_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> solves an overdetermined or underdetermined linear system using gels. pure subroutine gels_rel ( A , b , x , info ) use external_interfaces_solver , only : gels ! inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! input matrix A real ( rk ), dimension (:), contiguous , intent ( in ) :: b ! right-hand side matrix b ! outputs: real ( rk ), dimension ( max ( 1 , size ( A , 2 ))), intent ( out ) :: x ! solution matrix x integer , intent ( out ) :: info ! result info ! local variables character ( 1 ) :: trans integer :: m , n , lda , ldb , lwork , nrhs real ( rk ), allocatable :: work (:) real ( rk ) :: work1 ( 1 ) real ( rk ), dimension (:,:), allocatable :: a_copy real ( rk ), dimension (:,:), allocatable :: b_copy ! trans = 'n' ! get dimensions nrhs = 1 ! size(b, 2) m = size ( A , 1 ) n = size ( A , 2 ) lda = max ( 1 , m ) ldb = max ( 1 , max ( m , n )) ! copy the input matrices a_copy = a allocate ( b_copy ( ldb , nrhs )) b_copy (:, 1 ) = b ! calculate the optimal size of the work array call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work1 , - 1 , info ) ! allocate work array lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) ! call gels subroutine call gels ( trans , m , n , nrhs , a_copy , lda , b_copy , ldb , work , lwork , info ) ! copy the solution matrix if ( info == 0 ) then if ( trans == 'n' ) x = b_copy ( 1 : n , 1 ) ! nrhs = 1 if ( trans == 't' ) x = b_copy ( 1 : m , 1 ) ! nrhs = 1 else error stop 'gels failed' end if ! deallocate workspace deallocate ( work ) end subroutine gels_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_rel_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun1 ( x ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: Fun1 end function Fun1 impure function dFun1 ( x ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: dFun1 end function dFun1 end interface procedure ( Fun1 ) :: F procedure ( dFun1 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , x0 , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)         dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) !  case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) !  case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T0(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_rel_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_rel_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun2 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun2 impure function dFun2 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun2 end interface procedure ( Fun2 ) :: F procedure ( dFun2 ), optional :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton' ) call newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-modified' ) call modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) case ( 'newton-quasi-fd' ) call quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-fd-modified' ) call modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) ! case ('newton-quasi-bfgs') !    call quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) ! case ('newton-quasi-bfgs-modified') !    call modified_quasi_bfgs_newton_method_T1(this, F, x0,  x_sol) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , x_sol ( i ) end do end if end subroutine newton_rel_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_complex_step_rel_T0 ( this , F , x0 , x_sol ) interface impure function Fun3 ( x ) result ( res ) import rk implicit none complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun3 end interface procedure ( Fun3 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             x0                   tol' print '(g0, 10x, f12.8, 10x, e12.4)' , this % maxit , real ( x0 , kind = rk ), this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it        xn           F(xn)        dF(xn)/dxn' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' print '(a, g0)' , 'x_sol = ' , x_sol end if end subroutine newton_complex_step_rel_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_complex_step_rel_T1 ( this , F , x0 , x_sol ) interface impure function Fun4 ( x ) result ( res ) import rk implicit none complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun4 end interface procedure ( Fun4 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol integer :: i if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'maxit             tol' print '(g0, 10x, f12.8, e12.4)' , this % maxit , this % TolFun print '(a)' , '-----------------------------------------------' print '(a)' , 'start newton' print '(a)' , '-----------------------------------------------' print '(a)' , 'it     ||F||' end if select case ( this % nl_method ) case ( 'newton-quasi-cs' ) call quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) case ( 'newton-quasi-cs-modified' ) call modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) end select if ( this % verbosity == 1 ) then print '(a)' , '-----------------------------------------------' print '(a)' , 'end newton' print '(a)' , '-----------------------------------------------' do i = 1 , size ( x_sol ) print '(a, g0)' , 'x_sol = ' , real ( x_sol ( i ), kind = rk ) end do ! print '(a, g0)', 'x_sol = ', x_sol end if end subroutine newton_complex_step_rel_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine set_options ( this ,& nl_method , lin_method , maxit , TolFun , alpha0 , c1 , c2 , nmp , fdm_method , fdm_tol , cs_tol , stepsize , verbosity ) class ( nlsolver ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: nl_method character ( * ), intent ( in ), optional :: lin_method character ( * ), intent ( in ), optional :: stepsize character ( * ), intent ( in ), optional :: fdm_method real ( rk ), intent ( in ), optional :: TolFun real ( rk ), intent ( in ), optional :: fdm_tol real ( rk ), intent ( in ), optional :: cs_tol integer , intent ( in ), optional :: maxit real ( rk ), intent ( in ), optional :: alpha0 real ( rk ), intent ( in ), optional :: c1 real ( rk ), intent ( in ), optional :: c2 integer , intent ( in ), optional :: nmp integer , intent ( in ), optional :: verbosity if ( present ( nl_method )) then this % nl_method = nl_method else this % nl_method = 'newton' end if if ( present ( lin_method )) then this % lin_method = lin_method else this % lin_method = 'gels' end if if ( present ( fdm_method )) then this % fdm_method = fdm_method else this % fdm_method = 'forward' end if if ( present ( maxit )) then this % maxit = maxit else this % maxit = 100 end if if ( present ( TolFun )) then this % TolFun = TolFun else this % TolFun = 1e-4_rk end if if ( present ( fdm_tol )) then this % fdm_tol = fdm_tol else this % fdm_tol = 1e-4_rk end if if ( present ( cs_tol )) then this % cs_tol = cs_tol else this % cs_tol = 1e-100_rk end if if ( present ( nmp )) then this % nmp = nmp else this % nmp = 2 end if if ( present ( verbosity )) then this % verbosity = verbosity else this % verbosity = 1 end if ! if (present(stepsize))   this%stepsize   = stepsize ! if (present(alpha0))     this%alpha0     = alpha0 ! if (present(c1))         this%c1         = c1 ! if (present(c2))         this%c2         = c2 end subroutine set_options !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine deallocate_solver ( this ) type ( nlsolver ), intent ( inout ) :: this if ( allocated ( this % nl_method )) deallocate ( this % nl_method ) if ( allocated ( this % fdm_method )) deallocate ( this % fdm_method ) end subroutine deallocate_solver !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun5 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun5 impure function dFun5 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun5 end interface procedure ( Fun5 ) :: F procedure ( dFun5 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_newton_method_T0 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun6 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun6 impure function dFun6 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function dFun6 end interface procedure ( Fun6 ) :: F procedure ( dFun6 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = dFdx ( xk ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun7 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun7 end interface procedure ( Fun7 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_fd_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun8 ( x ) result ( res ) import rk implicit none real ( rk ), intent ( in ) :: x real ( rk ) :: res end function Fun8 end interface procedure ( Fun8 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), intent ( in ) :: x0 real ( rk ), intent ( out ) :: x_sol real ( rk ) :: xk real ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: pk real ( rk ) :: qk real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , xk , F_val , dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun9 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun9 impure function dFun10 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun10 end interface procedure ( Fun9 ) :: F procedure ( dFun10 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_newton_method_T1 ( this , F , dFdx , x0 , x_sol ) interface impure function Fun11 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun11 impure function dFun11 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: res end function dFun11 end interface procedure ( Fun11 ) :: F procedure ( dFun11 ) :: dFdx class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = dFdx ( xk ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun12 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun12 end interface procedure ( Fun12 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_fd_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_fd_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun13 ( x ) result ( res ) import rk implicit none real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: res end function Fun13 end interface procedure ( Fun13 ) :: F class ( nlsolver ), intent ( inout ) :: this real ( rk ), dimension (:), intent ( in ) :: x0 real ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol real ( rk ), dimension ( size ( x0 )) :: xk real ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if (( mod ( k , this % nmp ) == 0 )) dFdx_val = derivative ( f = F , x = xk , h = this % fdm_tol , method = this % fdm_method ) criteriaFun = norm2 ( F_val ) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , F_val , this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_fd_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun14 ( x ) result ( res ) import rk implicit none complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun14 end interface procedure ( Fun14 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_cs_newton_method_T0 ( this , F , x0 , x_sol ) interface impure function Fun15 ( x ) result ( res ) import rk implicit none complex ( rk ), intent ( in ) :: x complex ( rk ) :: res end function Fun15 end interface procedure ( Fun15 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: x0 complex ( rk ), intent ( out ) :: x_sol complex ( rk ) :: xk complex ( rk ) :: F_val real ( rk ) :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = abs ( F_val ) if ( this % verbosity == 1 ) then print '(g0, f12.4, 4x, e12.4, 4x, e12.4)' , k , real ( xk , kind = rk ), real ( F_val , kind = rk ), dFdx_val end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - F_val / dFdx_val alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun16 ( x ) result ( res ) import rk implicit none complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun16 end interface procedure ( Fun16 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine quasi_cs_newton_method_T1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine modified_quasi_cs_newton_method_T1 ( this , F , x0 , x_sol ) interface impure function Fun17 ( x ) result ( res ) import rk implicit none complex ( rk ), dimension (:), intent ( in ) :: x complex ( rk ), dimension (:), allocatable :: res end function Fun17 end interface procedure ( Fun17 ) :: F class ( nlsolver ), intent ( inout ) :: this complex ( rk ), dimension (:), intent ( in ) :: x0 complex ( rk ), dimension ( size ( x0 )), intent ( out ) :: x_sol complex ( rk ), dimension ( size ( x0 )) :: xk complex ( rk ), dimension (:), allocatable :: F_val real ( rk ), dimension (:,:), allocatable :: dFdx_val real ( rk ) :: criteriaFun integer :: k logical :: convergenz real ( rk ), dimension ( size ( x0 )) :: dk real ( rk ) :: alphak k = 0 xk = x0 convergenz = . false . do while (. not . convergenz . and . k < this % maxit ) F_val = F ( xk ) if ( mod ( k , this % nmp ) == 0 ) dFdx_val = derivative ( f = F , x = real ( xk , kind = rk ), h = this % cs_tol ) criteriaFun = norm2 ( real ( F_val , kind = rk )) if ( this % verbosity == 1 ) then print '(g0, e12.4)' , k , criteriaFun end if if ( criteriaFun <= this % TolFun ) then convergenz = . true . x_sol = xk return else dk = - solve ( dFdx_val , real ( F_val , kind = rk ), this % lin_method ) alphak = 1.0_rk xk = xk + alphak * dk k = k + 1 end if end do end subroutine modified_quasi_cs_newton_method_T1 !=============================================================================== end module forsolver","tags":"","url":"sourcefile/forsolver.f90.html"},{"title":"test_solver10.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver10.f90~~EfferentGraph sourcefile~test_solver10.f90 test_solver10.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver10.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver10.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function10 use forsolver_kinds , only : rk implicit none contains function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3 function dF3dx ( x ) result ( dFdx_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: dFdx_val allocate ( dFdx_val ( 2 , 2 )) dFdx_val ( 1 , 1 ) = 120 0.0_rk * x ( 1 ) ** 2 - 40 0.0_rk * x ( 2 ) + 2.0_rk dFdx_val ( 1 , 2 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 1 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 2 ) = 20 0.0_rk end function dF3dx end module my_function10 program test_solver10 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function10 , only : F3 , dF3dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton-modified' ,& nmp = 1 ,& maxit = 100 ,& TolFun = 1e-15_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , dFdx = dF3dx , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver10' ) end program test_solver10","tags":"","url":"sourcefile/test_solver10.f90.html"},{"title":"test_solver9.f90 – ForSolver","text":"This file depends on sourcefile~~test_solver9.f90~~EfferentGraph sourcefile~test_solver9.f90 test_solver9.f90 sourcefile~forsolver.f90 forsolver.f90 sourcefile~test_solver9.f90->sourcefile~forsolver.f90 sourcefile~forsolver_kinds.f90 forsolver_kinds.F90 sourcefile~test_solver9.f90->sourcefile~forsolver_kinds.f90 sourcefile~forsolver.f90->sourcefile~forsolver_kinds.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~forsolver.f90->sourcefile~external_interfaces.f90 sourcefile~external_interfaces.f90->sourcefile~forsolver_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_function9 use forsolver_kinds , only : rk implicit none contains function F3 ( x ) result ( F_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:), allocatable :: F_val allocate ( F_val ( 2 )) F_val ( 1 ) = 2.0_rk * x ( 1 ) - 40 0.0_rk * x ( 1 ) * ( x ( 2 ) - x ( 1 ) ** 2 ) - 2.0_rk F_val ( 2 ) = 20 0.0_rk * x ( 2 ) - 20 0.0_rk * x ( 1 ) ** 2 end function F3 function dF3dx ( x ) result ( dFdx_val ) real ( rk ), dimension (:), intent ( in ) :: x real ( rk ), dimension (:,:), allocatable :: dFdx_val allocate ( dFdx_val ( 2 , 2 )) dFdx_val ( 1 , 1 ) = 120 0.0_rk * x ( 1 ) ** 2 - 40 0.0_rk * x ( 2 ) + 2.0_rk dFdx_val ( 1 , 2 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 1 ) = - 40 0.0_rk * x ( 1 ) dFdx_val ( 2 , 2 ) = 20 0.0_rk end function dF3dx end module my_function9 program test_solver9 use forsolver_kinds , only : rk use forsolver , only : nlsolver use my_function9 , only : F3 , dF3dx use forunittest , only : unit_test implicit none type ( nlsolver ) :: nls real ( rk ), dimension ( 2 ) :: x , expected_x type ( unit_test ) :: ut call nls % set_options (& nl_method = 'newton' ,& maxit = 100 ,& TolFun = 1e-15_rk ,& verbosity = 0 ) call nls % solve ( F = F3 , dFdx = dF3dx , x0 = [ 0.95_rk , 0.95_rk ], x_sol = x ) ! check if solution is close to [1,1] expected_x = [ 1.0_rk , 1.0_rk ] call ut % check ( x , expected_x , 1.0e-5_rk , 'test_solver9' ) end program test_solver9","tags":"","url":"sourcefile/test_solver9.f90.html"}]}